<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Anko Layout | HaKuLess</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://hakuless.github.io//favicon.ico?v=1557325276933">
<link rel="stylesheet" href="https://hakuless.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://hakuless.github.io/">
        <img src="https://hakuless.github.io//images/avatar.png?v=1557325276933" class="site-logo">
        <h1 class="site-title">HaKuLess</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/HakuLess" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Anko Layout</h2>
            <div class="post-date">2017-11-07</div>
            
            <div class="post-content">
              <p><a href="https://github.com/Kotlin/anko/wiki/Anko-Layouts#why-anko-layouts">github说明</a>
Kotlin支持的一种新的，以DSL方式并通过Kotlin代码组件UI的功能。可以让RD完全抛弃使用xml写layout，节约开发时间，规避许多潜在bug</p>
<!--more-->
<h3 id="使用demo">使用Demo</h3>
<p>在Activity or Fragment中的onCreate方法中直接写代码：</p>
<pre><code class="language-kotlin">scrollView {
    verticalLayout {

        // 顶部模块
        val topLayout = linearLayout {
            backgroundColor = resources.getColor(R.color.black)
        }.lparams(width = matchParent, height = dip(30))

        textView(&quot;textview&quot;) {
            textSize = 20f
            gravity = Gravity.CENTER
        }.lparams(width = matchParent, height = dip(300))

        recyclerView {
            val lm = LinearLayoutManager(context)
            lm.orientation = LinearLayoutManager.HORIZONTAL
            layoutManager = lm

            adapter = MegamiAdapter()
        }

        button(&quot;点击&quot;) {
            onClick {
                topLayout.setBackgroundColor(resources.getColor(R.color.white))
            }
        }
    }
}

</code></pre>
<p>一步一步来看，最外层scrollView表示根布局是个ScrollView，与xml不同，可以省略width &amp; height的填写，默认为wrap_content，整体结构与layout.xml的写法相似，使用DSL方式表示各个View的从属关系。
每个View的属性赋值可以在三个地方操作：</p>
<ul>
<li>layoutParams可以通过最后的lparams方法设置（如width、height、weight &amp; gravity）xml中layout_前缀的属性，包括margin、gravity等</li>
<li>View的构造函数，如textview 和 button 支持单一String参数的构造函数，会把该参数settext</li>
<li>View的域内可以调用View的所有方法，如上述recyclerView，可在其内部设置adapter、layoutManager等</li>
</ul>
<p>除此之外，DSL方法的返回值即View本身，对于需要持有的View可以通过常量获取内容，如上述topLayout赋值为顶部的linearLayout，可以在底部的button中的点击方法中改变其背景颜色</p>
<h3 id="优点">优点</h3>
<ul>
<li>类型安全不会出现LinearLayout转RelativeLayout之类的低级crash问题</li>
<li>Null安全不存在findViewById找不到的情况，layout文件与id不匹配，比如被其他aar中的layout覆盖等bug</li>
<li>节约时间反射解析XML耗费CPU及电池，而且在一些极端情况下，容易发生找不到id的error（如freeline or instantRun）</li>
<li>与Layout共存个人更喜欢纯净的、全部都使用Anko Layout，但对于历史项目 or 使用DSL方式实现有一定麻烦的，可以允许通过include关键字反射View</li>
</ul>
<pre><code class="language-kotlin">include&lt;View&gt;(R.layout.something) {
    backgroundColor = Color.RED
}.lparams(width = matchParent) { margin = dip(12) }
</code></pre>
<h3 id="缺点">缺点</h3>
<ul>
<li>RelativeLayout及一些其他依赖id的Layout与R文件直接增加的 @+id不同，Anko Layout需要自己设置id的值，即人工保证id的唯一性所有需要人来保障的都是不可靠的...</li>
<li>Preview功能，通过xml写Layout时可以通过AS的Preview功能在无需build的情况下就可以查看布局的效果，并可以通过配合tools来查看填写不同参数时的效果，如文案一行、多行、省略号等然而目前Anko Layout的Preview仅支持Android Studio 2.4+（3.0上不好使...）目前Plugin版本号为Anko Support 0.10.2，Android Studio版本号为Android Studio 3.0 beta7<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8cxm27odj30qq0w0weu.jpg" alt=""></li>
</ul>
<h2 id="原理">原理</h2>
<p>首先，通过⌃+⌘+K快捷键可以调用Kotlin Byecode，对于JVM来讲，Kotlin和Java没有区别，甚至二者可以任意的互相转换、调用~
以一个简单的Demo，让我们一起来探索下通过DSL书写布局的秘密！</p>
<h3 id="代码准备">代码准备</h3>
<pre><code class="language-kotlin">inline fun ViewManager.verticalLayout(theme: Int = 0, init: _LinearLayout.() -&gt; Unit): LinearLayout {
    return ankoView(`$$Anko$Factories$CustomViews`.VERTICAL_LAYOUT_FACTORY, theme, init)
}
</code></pre>
<p>上述代码，verticalLayout方法支持2个参数，其中第一个参数是默认值，第二个参数是一个方法（高阶函数以方法作为参数），方法的输入是一个返回值为空的方法（结合Lambda表达式）
<strong>init: _LinearLayout.() -&gt; Unit</strong>
这里是相当于执行_LinearLayout中的空方法，之后在 **{ } **所写的具体View代码相当于执行LinearLayout的相应方法，可看下文一个简单代码示例：</p>
<pre><code class="language-kotlin">val represents: String.(Int) -&gt; Boolean = { other -&gt; toIntOrNull() == other }
println(&quot;123&quot;.represents(123)) // true
</code></pre>
<h3 id="demo分析">DEMO分析</h3>
<pre><code class="language-kotlin">class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) {
        super.onCreate(savedInstanceState, persistentState)
        MyActivityUI().setContentView(this)
    }
}

class MyActivityUI : AnkoComponent&lt;MyActivity&gt; {
    override fun createView(ui: AnkoContext&lt;MyActivity&gt;) = ui.apply {
        verticalLayout {
            val name = editText()
            button(&quot;Say Hello&quot;) {
                onClick { ctx.toast(&quot;Hello, ${name.text}!&quot;) }
            }
        }
    }.view
}
</code></pre>
<p>上述布局很简单，就是一个垂直的LinearLayout中，第一行是一个EditText，第二行是一个Button，并且点击Btn的时候会弹出Toast，其中的内容是用户在editText中输入的数据的一个拼装
但是这个Layout是如何进入contentView的呢？
如果正常只通过Java代码来写这个功能的代码，就是自己new一大堆View，然后通过addView一点一点的组进去，Anko Layout是如何模仿这一过程的呢？</p>
<ul>
<li>通过⌃+⌘+K快捷键打开Bytecode的面板（代码可读性还是比较低的... 用行内的话就是，观影体验极差）<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8e0r9d8zj31kw0umacd.jpg" alt=""></li>
<li>通过点击Bytecode面板中的Decompile将其反编译为Java code<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl8e4w487gj31kw0t677s.jpg" alt="">对于两种DSL使用方法略有不同，一种是直接在onCreate中写DSL代码，另一种是通过一个外部类继承AnkoComponent，并复写其中的createView方法。两种没有本质上的区别，本Demo以第二种来进行说明（算是包括了第一种，只是通过AnkoComponent转了一层，加强Layout的复用功能）</li>
<li>入口方法为 <strong>MyActivityUI().setContentView(this)</strong> 其中setContentView为AnkoComponent的一个扩展，在内部方法中返回实现的AnkoComponent中createView方法创造的View。而 <strong>ui.apply</strong> 方法使其作用域内部任意调用ui的方法，即我们所写的DSL风格的代码其实一样是一个一个的方法，只是省略掉的调用的实例，使其外貌上看上去像是xml写的layout~</li>
<li>ui的类型为 <strong>interface AnkoContext<out T> : ViewManager</strong> kotlin的interface与java的不同，可以持有变量 并且 方法允许有默认的实现（靠近虚类），其中泛型的in &amp; out也与Java的 T extends 与 super类似，定制所需类型的上界下界，通过in、out方式更直观的通过该类型是输入类型 or 输出类型来判断，更符合人的直观感受🙃通过扩展ViewManager的方法，加入了verticalLayout等一系列Layout的实现，实现了添加View的方法！</li>
<li>通过ankoView生成相应的View，比如verticalLayout生成LinearLayout在CustomViews.kt文件中，代码如下</li>
</ul>
<pre><code>inline fun ViewManager.verticalLayout(theme: Int = 0, init: _LinearLayout.() -&gt; Unit): LinearLayout {
    return ankoView(`$$Anko$Factories$CustomViews`.VERTICAL_LAYOUT_FACTORY, theme, init)
}
</code></pre>
<ul>
<li>而ankoView方法中，通过传入的factory来创建view（factory为一个高阶函数，接收context参数返回一个View），并通过AnkoInternals来addView，而internals中的addView即调用ViewGroup or AnkoContext中的addView方法（其实都一样(￣▽￣)&quot;）</li>
<li>接下来又是一大长串，我还是代码+图片来阐述吧... 这个用文字要打太多了，估计你也看不下去😂AnkoInternals.addView -&gt; createAnkoContext -&gt; AnkoContextImpl -&gt; addView -&gt; doAddView每一个DSL风格的域经过一轮解析创建好View之后并在之后add进其上下文，同时判断其上下文如果是Activity则setContentView作为根节点（对于内部View则是判断ViewManager是ViewGroup or AnkoContext） 通过这种方式实现，普通的onCreate中的直接使用viewGroup &amp; 自定义UI继承AnkoComponent 两种方案。</li>
</ul>
<h3 id="整体时序图">整体时序图</h3>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8m3hvgraj31h80u03zm.jpg" alt="">
如上述时序图所示，View的创建一层一层的传递下去，其中共有三种情况，即创建View的三种上下文：</p>
<ul>
<li>Activity，在Activity的onCreate中调用，判断到最后通过setContentView来填充整个布局</li>
<li>Context &amp; Fragment，在其他场景下创建的View，可直接通过UI { } 域生成相应的View</li>
<li>AnkoContext，在自定义AnkoComponent中的createView方法中定义</li>
</ul>
<p>其中第N步开始，即需要根据上下文的不同进入的深度不同，但最终都是返回View（中间可能会进行setContentView操作）</p>
<h2 id="thanks-to">Thanks To</h2>
<p><a href="https://github.com/Kotlin/anko/wiki/Anko-Layouts#why-anko-layouts">github说明</a></p>
<p><a href="http://kotlinlang.org/docs/reference/lambdas.html">Kotlin官方文档</a></p>
<p><a href="http://www.jianshu.com/p/6dca03569c09">Anko的源码解析</a></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://hakuless.github.io//tag/gEjrhrmNK" class="tag">
                    Kotlin
                  </a>
                
                  <a href="https://hakuless.github.io//tag/tech" class="tag">
                    Tech
                  </a>
                
                  <a href="https://hakuless.github.io//tag/android" class="tag">
                    Android
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://hakuless.github.io//post/freeline-da-bao-liu-cheng-chu-tan">
                  <h3 class="post-title">
                    Freeline打包流程初探
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
