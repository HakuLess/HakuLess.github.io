
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Union-Find Set | HaKuLess</title>
<meta name="description" content="精神病人思路广，脑残儿童欢乐多">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://hakuless.github.io//favicon.ico?v=1580702093970">
<link rel="stylesheet" href="https://hakuless.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://hakuless.github.io/">
        <img class="avatar" src="https://hakuless.github.io//images/avatar.png?v=1580702093970" alt="" width="32px" height="32px">
      </a>
      <a href="https://hakuless.github.io/">
        <h1 class="site-title">HaKuLess</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://hakuless.github.io//post-images/union-find-set.png')">
            </div>
          
          <h2 class="post-title">Union-Find Set</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2019-05-25</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://hakuless.github.io/tag/IljgdPijv">
                    LeetCode
                    
                      ，
                    
                  </a>
                
                  <a href="https://hakuless.github.io/tag/B6a_MNeCC">
                    Data Structure
                    
                      ，
                    
                  </a>
                
                  <a href="https://hakuless.github.io/tag/kXyJVahYw">
                    Algorithm
                    
                      ，
                    
                  </a>
                
                  <a href="https://hakuless.github.io/tag/tech">
                    Tech
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h2 id="introduction">Introduction</h2>
<p>并查集是个很有意思的数据结构，它的主要功能是把不同的元素 分组 并 关联 起来，能够在 O(1) 时间内判断两个元素是否在一组里。关系具有传递性的问题，都可以利用并查集处理。</p>
 <!-- more -->
<h2 id="function">function</h2>
<p>并查集的核心主要是两个方法，一个是查找 <strong>find(x)</strong>，通过传入元素，返回元素所在组的Key（不同元素返回的Key值相同，代表这些元素在同一组里）。另一个是 <strong>union(x, y)</strong>，将两个不同的元素合并为一组，同时属于这两组的数据都在一个大组内。</p>
<pre><code>class UnionFindSet:
	func UnionFindSet(n):
		parents = [1..n]
		rank = [0..0] (n zeros)
	
	func Find(x):
		if x != parents[x]:
			parents[x] = Find(parents[x])
		return parents[x]
		
	func Union(x, y):
		px, py = Find(x), Find(y)
		if ranks[px] &gt; ranks[py]: parents[py] = px
		if ranks[px] &lt; ranks[py]: parents[px] = py
		if ranks[px] == ranks[py]
			parents[py] = px
			ranks[px]++
</code></pre>
<p>上面是伪代码，注意到有两个部分：</p>
<ol>
<li>find(x) 通过递归一直向上寻找，并不断的赋值</li>
<li>union(x, y)过程，会根据 ranks值进行比较，然后merge方式不同</li>
</ol>
<h3 id="path-compression">Path Compression</h3>
<p>首先，find寻找过程中同时进行 <strong>path compression</strong> 优化，如建立关联关系时，整个关联图的关系非常的长，如下图：<br>
<img src="https://hakuless.github.io//post-images/1558768567180.png" alt="" loading="lazy"><br>
当我们要查找1所在组时，会一直遍历到链表头，会非常耗时，因此需要在find过程中进行优化，把1、2、3、5（查找的数据及其所有祖先）均直接指向8（Class ID），拉平我们的树结构（flatten the structure），变成如下图所示：<br>
<img src="https://hakuless.github.io//post-images/1558768774411.png" alt="" loading="lazy"><br>
这时候我们再次查找时，会大大减少遍历所需时间</p>
<h3 id="union-by-rank">Union By Rank</h3>
<p>合并的过程，我们通过Union By Rank来进行优化，原理与上述内容类似，就是为了减少我们查找过程中的耗时。由于我们的merge过程就是把一个组的根节点直接指向另一个组的根节点，那么如果把一个很复杂的结构+到一个简单结构上，会增加整个树的深度，反之则不会增大复杂度。因此我们尽量让深度小的树 attach 到深度大的树上，效果如下图：<br>
<img src="https://hakuless.github.io//post-images/1558769263768.png" alt="两组进行合并" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769351883.png" alt="小树attach大树" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769433973.png" alt="大树attach小树" loading="lazy"><br>
可以明显看出，当大树attach小树时，复杂度明显增加，通过一个rank数组记录每一次做深节点的操作（Rank值相同的合并），并用于判断以后的union操作</p>
<h2 id="leetcode">LeetCode</h2>
<h3 id="684-redundant-connection">684. Redundant Connection</h3>
<p>标准的并查集题目，给出一组无向图的边，找到第一个使无相同中产生环的边 =&gt;<br>
转化为 将给出的边，按顺序把所有的点进行分组，直到发现某条边在添加之前，边的两个点就已经在一组里了，那么此时若加入这条边，即会产生环。</p>
<pre><code>class Solution {
    fun findRedundantConnection(edges: Array&lt;IntArray&gt;): IntArray {
        val dsu = DSU(edges.size)
        for (i in 0 until edges.size) {
            val x = edges[i][0] - 1
            val y = edges[i][1] - 1
            if (dsu.find(x) == dsu.find(y)) {
                return intArrayOf(x + 1, y + 1)
            }
            dsu.union(x, y)

        }
        return intArrayOf()
    }
}
</code></pre>
<h3 id="547-friend-circles">547. Friend Circles</h3>
<p>这个数据更直接的并查集题目，以二维数组形式 给出一个班级同学之间的朋友关系，1是朋友 0不是，同时 朋友的朋友也是朋友（...），然后给出整个班级一共有多少的朋友圈。。。</p>
<pre><code>class Solution {
    fun findCircleNum(M: Array&lt;IntArray&gt;): Int {
        val size = M.size
        val dsu = DSU(size)
        for (i in 0 until size) {
            for (j in 0 until size) {
                if (M[i][j] == 1 &amp;&amp; i != j) {
                    dsu.union(i, j)
                }
            }
        }

        val ans = HashSet&lt;Int&gt;()
        for (i in 0 until size) {
            ans.add(dsu.find(i))
        }
        return ans.size
    }
}
</code></pre>
<p>这里将所有的关系，录入到并查集中，然后遍历所有的学生所属的组放到Set里，那么Set的长度就是朋友圈的数量</p>
<h3 id="947-most-stones-removed-with-same-row-or-column">947. Most Stones Removed with Same Row or Column</h3>
<p>一般并查集的微变形，一个二维棋盘上，散落着一堆石头（每个石头一个点 且 不会有重复），然后我们可以一次一个的取下石头（对石头有要求，需要有其他石头和取下的石头在同一行 or 同一列，即自己单独一行 &amp; 一列 的石头无法取下，天煞孤石）<br>
这里，一组的属性是 行数 or 列数相同，Solution里给出的方案是根据 <strong>Note</strong> 中入参的限制来把 <em>列</em> 转换为 10000+的 <em>行</em> 数，我们这里采用更通用的办法，通过一个Map转换我们的Class ID与数据（ID与属性不需要有强关系）</p>
<pre><code>class Solution {
    fun removeStones(stones: Array&lt;IntArray&gt;): Int {
        val max = stones.size
        val ufs = TypedUFS&lt;IntArray&gt;(max)
        for (i in 0 until max) {
            for (j in i + 1 until max) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ufs.union(stones[i], stones[j])
                }
            }
        }

        val set = hashSetOf&lt;Int&gt;()
        stones.forEach {
            val root = ufs.typedFind(it)
            set.add(root)
        }

        return stones.size - set.size
    }
}

class TypedUFS&lt;T&gt;(var n: Int = 0) {
    val parent = IntArray(n) { i -&gt; i }
    val rank = IntArray(n)

    val map = hashMapOf&lt;T, Int&gt;()
    var total = 0

    fun typedFind(key: T): Int {
        var x = total
        if (map.containsKey(key)) {
            x = map[key]!!
        } else {
            map[key] = total
            total++
        }
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun find(x: Int): Int {
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun union(x: T, y: T): Boolean {
        val px = typedFind(x)
        val py = typedFind(y)
        if (px == py) {
            return false
        }
        when {
            rank[px] &gt; rank[py] -&gt; parent[py] = px
            rank[px] &lt; rank[py] -&gt; parent[px] = py
            else -&gt; {
                parent[px] = py
                rank[px]++
            }
        }
        return true
    }
}
</code></pre>
<p>把行、列有相同情况的元素union在一起，每个组都会留下一个元素，因此我们能有拿走的石头的最大数量就是 石头的数量 减去 并查集组的数量（与之前朋友圈的题目相似）。这里我们使用了一个 <strong>TypedUFS</strong> 来处理非int类型的源数据，map每次分配一个新元素一个新的Key值，最大程度的减少 <strong>parent</strong> 与 <strong>rank</strong> 数组的长度（最大只需要数据源的长度，而非数据源的范围，与Solution的区别）</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://zxi.mytechroad.com/blog/data-structure/sp1-union-find-set/">花花LeetCode</a><br>
<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">wiki</a></p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://hakuless.github.io/post/binary-search">
              <h3 class="post-title">
                下一篇：Binary Search
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">精神病人思路广，脑残儿童欢乐多</div>
  <div class="social-container">
    
      
        <a href="https://github.com/HakuLess" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
