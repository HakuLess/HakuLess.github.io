<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hakuless.github.io/</id>
    <title>HaKuLess</title>
    <updated>2020-02-03T03:50:49.075Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hakuless.github.io/"/>
    <link rel="self" href="https://hakuless.github.io/atom.xml"/>
    <subtitle>精神病人思路广，脑残儿童欢乐多</subtitle>
    <logo>https://hakuless.github.io/images/avatar.png</logo>
    <icon>https://hakuless.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, HaKuLess</rights>
    <entry>
        <title type="html"><![CDATA[1114. Print in Order —— 题解]]></title>
        <id>https://hakuless.github.io/post/1114-print-in-order-ti-jie</id>
        <link href="https://hakuless.github.io/post/1114-print-in-order-ti-jie">
        </link>
        <updated>2020-02-03T03:32:34.000Z</updated>
        <summary type="html"><![CDATA[<p>最近工作中终于有些多线程的Case了，玩一玩LeetCode多线程的题目，复习一下知识（N久没有开发过多线程交互的代码了...）</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近工作中终于有些多线程的Case了，玩一玩LeetCode多线程的题目，复习一下知识（N久没有开发过多线程交互的代码了...）</p>
<!-- more -->
<h3 id="原题描述">原题描述</h3>
<p>给定一个如下的类Foo，ABC三个线程分别调用 first、second、third方法，但是无论ABC的调用顺序如何，我们的输出顺序保持着1、2、3</p>
<pre><code class="language-Kotlin">public class Foo {
  public void first() { print(&quot;first&quot;); }
  public void second() { print(&quot;second&quot;); }
  public void third() { print(&quot;third&quot;); }
}
</code></pre>
<h3 id="变种">变种</h3>
<p>由于LeetCode上的多线程题目不支持Kotlin代码，因此自己设置主函数 并 稍微改变下题目，方便观察结果<br>
首先，我们把主函数设置为如下代码：</p>
<pre><code class="language-Kotlin">fun main(args: Array&lt;String&gt;) {
    val max = 1000
    val s = Foo()
    thread {
        for (i in 0..max)
            s.first()
    }
    thread {
        for (i in 0..max)
            s.second()
    }
    thread {
        for (i in 0..max)
            s.third()
    }
}
</code></pre>
<ol>
<li>共有三个不同线程，每个线程自己会去执行Foo的first、second、third方法各1001次</li>
<li>我们希望打印first先执行，然后执行second，再执行third(循环反复)</li>
<li>最终每个打印都1001次，共计3003次</li>
</ol>
<h3 id="解法一countdownlatch">解法一：CountDownLatch</h3>
<ol>
<li>分别设置三个不同的CountDownLatch，分别拦截first、second、third</li>
<li>最开始first不用拦截，默认设置c0为0</li>
<li>执行自己时，将下一道门countDown掉（每个执行都到等待自己的门）</li>
<li>执行完成自己，重新把自己的门闩设置上（防止重复执行某一个）</li>
</ol>
<pre><code class="language-Kotlin">class Foo {
    private var c0 = CountDownLatch(0)
    private var c1 = CountDownLatch(1)
    private var c2 = CountDownLatch(1)

    fun first() {
        c0.await()
        println(&quot;first&quot;)
        c0 = CountDownLatch(1)
        c1.countDown()
    }

    fun second() {
        c1.await()
        println(&quot;second&quot;)
        c1 = CountDownLatch(1)
        c2.countDown()
    }

    fun third() {
        c2.await()
        println(&quot;third&quot;)
        c2 = CountDownLatch(1)
        c0.countDown()
    }
}
</code></pre>
<h3 id="解法二-reentrantlock-with-condition">解法二： ReentrantLock with Condition</h3>
<ol>
<li>使用变量cur，代表当前允许执行的方法</li>
<li>首先在first、second、third中都加入lock()和unlock()，保证每次只会有一个方法执行</li>
<li>执行时进行变量判断，根据条件执行打印 or condition.wait()</li>
<li>执行完成后，修改变量cur &amp;&amp; 提示下一个condition可以执行</li>
</ol>
<pre><code class="language-Kotlin">class Foo {

    private val lock = ReentrantLock()

    var cur = 1
    private val c1 = lock.newCondition()
    private val c2 = lock.newCondition()
    private val c3 = lock.newCondition()

    fun first() {
        lock.lock()
        if (cur != 1) {
            c1.await()
        }
        println(&quot;first&quot;)
        cur = 2
        c2.signal()
        lock.unlock()
    }

    fun second() {
        lock.lock()
        if (cur != 2) {
            c2.await()
        }
        println(&quot;second&quot;)
        cur = 3
        c3.signal()
        lock.unlock()
    }

    fun third() {
        lock.lock()
        if (cur != 3) {
            c3.await()
        }
        println(&quot;third&quot;)
        cur = 1
        c1.signal()
        lock.unlock()
    }
}
</code></pre>
<h3 id="解法三-object锁-wait-notify">解法三： Object锁 &amp; wait &amp; notify</h3>
<p>该方法直接利用Object类中的wait方法（由于Kotlin中的Any并没有，因此需要使用as强转一下）停住线程</p>
<ol>
<li>通过 @Synchronized 注解使三个方法互斥</li>
<li>同样设置cur为当前可执行的方法变量</li>
<li>通过while循环判断是否可执行，不可执行则wait，可执行则执行并notifyAll</li>
</ol>
<p>注：</p>
<ol>
<li>这里需要用while判断，而非解法二中的if判断，主要是notifyAll会唤醒其他所有的wait，而wait唤醒后是继续执行，如果使用if则有可能条件仍不匹配，但是执行下去，导致与要求不符</li>
<li>可以看出解法三不如1、2的控制精准，能够唤醒特定线程</li>
</ol>
<pre><code class="language-Kotlin">class Foo {
    var cur = 1

    @Synchronized
    fun first() {
        while (cur != 1) {
            (this as Object).wait()
        }
        println(&quot;first&quot;)
        cur = 2
        (this as Object).notifyAll()
    }

    @Synchronized
    fun second() {
        while (cur != 2) {
            (this as Object).wait()
        }
        println(&quot;second&quot;)
        cur = 3
        (this as Object).notifyAll()
    }

    @Synchronized
    fun third() {
        while (cur != 3) {
            (this as Object).wait()
        }
        println(&quot;third&quot;)
        cur = 1
        (this as Object).notifyAll()
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1105. Filling Bookcase Shelves —— 题解]]></title>
        <id>https://hakuless.github.io/post/1105-filling-bookcase-shelves-ti-jie</id>
        <link href="https://hakuless.github.io/post/1105-filling-bookcase-shelves-ti-jie">
        </link>
        <updated>2019-07-03T07:19:48.000Z</updated>
        <summary type="html"><![CDATA[<p>本周状态不错，可惜好几周没有DP的题，一下卡住了...<br>
<a href="https://leetcode.com/problems/filling-bookcase-shelves/">https://leetcode.com/problems/filling-bookcase-shelves/</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>本周状态不错，可惜好几周没有DP的题，一下卡住了...<br>
<a href="https://leetcode.com/problems/filling-bookcase-shelves/">https://leetcode.com/problems/filling-bookcase-shelves/</a></p>
<!-- more -->
<h3 id="题目大意">题目大意</h3>
<p>给出一组书，书有宽、高，架子也有宽度，按照顺序从上向下摆放，问架子至少需要多高才能把书都放完，如下图所示：<br>
<img src="https://hakuless.github.io//post-images/1562138680833.png" alt="" loading="lazy"><br>
这里需要注意</p>
<ol>
<li>书是按顺序放的，所以4、5、6无法放到1的右侧，不属于贪心</li>
<li>换行策略，如2可以放在1的右侧，但是3就要另起一行，相对占用高度会更大</li>
</ol>
<h3 id="题解">题解</h3>
<p>使用动态规划求解这类 <strong>中间状态</strong> &amp;&amp; <strong>下一个输入</strong> 确定 <strong>下一个状态</strong> 的问题<br>
本题中，如果没有7的输入，那么高度会是5，而成为6原因是前6个输入的结果<br>
第7本书可以独立一行，or 与前边连续的n本书一起一行（n从0到6，总体宽度不可以大于架子宽度）<br>
那么 前6本书的最小高度也可以依照该逻辑求出，即每个状态下的最小高度，最后得出动态方程为</p>
<pre><code>// n从0取到K-1，直到它们总宽度大于架子宽度
dp[k] = minOf[dp[k], dp[k-n] + max[height{k-n..k}]]
</code></pre>
<p>具体题解代码如下：</p>
<pre><code class="language-Kotlin">fun minHeightShelves(books: Array&lt;IntArray&gt;, shelf_width: Int): Int {
		val n = books.size
		val height = IntArray(n + 1)
		for (i in 0 until n) {
				var min = Int.MAX_VALUE
				var h = 0
				var w = 0
				for (j in i downTo 0) {
						h = maxOf(h, books[j][1])
						w += books[j][0]
						if (w &gt; shelf_width) break
						min = minOf(min, h + height[j])
				}
				height[i + 1] = min
		}
		return height[n]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Union-Find Set]]></title>
        <id>https://hakuless.github.io/post/union-find-set</id>
        <link href="https://hakuless.github.io/post/union-find-set">
        </link>
        <updated>2019-05-25T03:51:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>并查集是个很有意思的数据结构，它的主要功能是把不同的元素 分组 并 关联 起来，能够在 O(1) 时间内判断两个元素是否在一组里。关系具有传递性的问题，都可以利用并查集处理。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>并查集是个很有意思的数据结构，它的主要功能是把不同的元素 分组 并 关联 起来，能够在 O(1) 时间内判断两个元素是否在一组里。关系具有传递性的问题，都可以利用并查集处理。</p>
 <!-- more -->
<h2 id="function">function</h2>
<p>并查集的核心主要是两个方法，一个是查找 <strong>find(x)</strong>，通过传入元素，返回元素所在组的Key（不同元素返回的Key值相同，代表这些元素在同一组里）。另一个是 <strong>union(x, y)</strong>，将两个不同的元素合并为一组，同时属于这两组的数据都在一个大组内。</p>
<pre><code>class UnionFindSet:
	func UnionFindSet(n):
		parents = [1..n]
		rank = [0..0] (n zeros)
	
	func Find(x):
		if x != parents[x]:
			parents[x] = Find(parents[x])
		return parents[x]
		
	func Union(x, y):
		px, py = Find(x), Find(y)
		if ranks[px] &gt; ranks[py]: parents[py] = px
		if ranks[px] &lt; ranks[py]: parents[px] = py
		if ranks[px] == ranks[py]
			parents[py] = px
			ranks[px]++
</code></pre>
<p>上面是伪代码，注意到有两个部分：</p>
<ol>
<li>find(x) 通过递归一直向上寻找，并不断的赋值</li>
<li>union(x, y)过程，会根据 ranks值进行比较，然后merge方式不同</li>
</ol>
<h3 id="path-compression">Path Compression</h3>
<p>首先，find寻找过程中同时进行 <strong>path compression</strong> 优化，如建立关联关系时，整个关联图的关系非常的长，如下图：<br>
<img src="https://hakuless.github.io//post-images/1558768567180.png" alt="" loading="lazy"><br>
当我们要查找1所在组时，会一直遍历到链表头，会非常耗时，因此需要在find过程中进行优化，把1、2、3、5（查找的数据及其所有祖先）均直接指向8（Class ID），拉平我们的树结构（flatten the structure），变成如下图所示：<br>
<img src="https://hakuless.github.io//post-images/1558768774411.png" alt="" loading="lazy"><br>
这时候我们再次查找时，会大大减少遍历所需时间</p>
<h3 id="union-by-rank">Union By Rank</h3>
<p>合并的过程，我们通过Union By Rank来进行优化，原理与上述内容类似，就是为了减少我们查找过程中的耗时。由于我们的merge过程就是把一个组的根节点直接指向另一个组的根节点，那么如果把一个很复杂的结构+到一个简单结构上，会增加整个树的深度，反之则不会增大复杂度。因此我们尽量让深度小的树 attach 到深度大的树上，效果如下图：<br>
<img src="https://hakuless.github.io//post-images/1558769263768.png" alt="两组进行合并" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769351883.png" alt="小树attach大树" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769433973.png" alt="大树attach小树" loading="lazy"><br>
可以明显看出，当大树attach小树时，复杂度明显增加，通过一个rank数组记录每一次做深节点的操作（Rank值相同的合并），并用于判断以后的union操作</p>
<h2 id="leetcode">LeetCode</h2>
<h3 id="684-redundant-connection">684. Redundant Connection</h3>
<p>标准的并查集题目，给出一组无向图的边，找到第一个使无相同中产生环的边 =&gt;<br>
转化为 将给出的边，按顺序把所有的点进行分组，直到发现某条边在添加之前，边的两个点就已经在一组里了，那么此时若加入这条边，即会产生环。</p>
<pre><code>class Solution {
    fun findRedundantConnection(edges: Array&lt;IntArray&gt;): IntArray {
        val dsu = DSU(edges.size)
        for (i in 0 until edges.size) {
            val x = edges[i][0] - 1
            val y = edges[i][1] - 1
            if (dsu.find(x) == dsu.find(y)) {
                return intArrayOf(x + 1, y + 1)
            }
            dsu.union(x, y)

        }
        return intArrayOf()
    }
}
</code></pre>
<h3 id="547-friend-circles">547. Friend Circles</h3>
<p>这个数据更直接的并查集题目，以二维数组形式 给出一个班级同学之间的朋友关系，1是朋友 0不是，同时 朋友的朋友也是朋友（...），然后给出整个班级一共有多少的朋友圈。。。</p>
<pre><code>class Solution {
    fun findCircleNum(M: Array&lt;IntArray&gt;): Int {
        val size = M.size
        val dsu = DSU(size)
        for (i in 0 until size) {
            for (j in 0 until size) {
                if (M[i][j] == 1 &amp;&amp; i != j) {
                    dsu.union(i, j)
                }
            }
        }

        val ans = HashSet&lt;Int&gt;()
        for (i in 0 until size) {
            ans.add(dsu.find(i))
        }
        return ans.size
    }
}
</code></pre>
<p>这里将所有的关系，录入到并查集中，然后遍历所有的学生所属的组放到Set里，那么Set的长度就是朋友圈的数量</p>
<h3 id="947-most-stones-removed-with-same-row-or-column">947. Most Stones Removed with Same Row or Column</h3>
<p>一般并查集的微变形，一个二维棋盘上，散落着一堆石头（每个石头一个点 且 不会有重复），然后我们可以一次一个的取下石头（对石头有要求，需要有其他石头和取下的石头在同一行 or 同一列，即自己单独一行 &amp; 一列 的石头无法取下，天煞孤石）<br>
这里，一组的属性是 行数 or 列数相同，Solution里给出的方案是根据 <strong>Note</strong> 中入参的限制来把 <em>列</em> 转换为 10000+的 <em>行</em> 数，我们这里采用更通用的办法，通过一个Map转换我们的Class ID与数据（ID与属性不需要有强关系）</p>
<pre><code>class Solution {
    fun removeStones(stones: Array&lt;IntArray&gt;): Int {
        val max = stones.size
        val ufs = TypedUFS&lt;IntArray&gt;(max)
        for (i in 0 until max) {
            for (j in i + 1 until max) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ufs.union(stones[i], stones[j])
                }
            }
        }

        val set = hashSetOf&lt;Int&gt;()
        stones.forEach {
            val root = ufs.typedFind(it)
            set.add(root)
        }

        return stones.size - set.size
    }
}

class TypedUFS&lt;T&gt;(var n: Int = 0) {
    val parent = IntArray(n) { i -&gt; i }
    val rank = IntArray(n)

    val map = hashMapOf&lt;T, Int&gt;()
    var total = 0

    fun typedFind(key: T): Int {
        var x = total
        if (map.containsKey(key)) {
            x = map[key]!!
        } else {
            map[key] = total
            total++
        }
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun find(x: Int): Int {
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun union(x: T, y: T): Boolean {
        val px = typedFind(x)
        val py = typedFind(y)
        if (px == py) {
            return false
        }
        when {
            rank[px] &gt; rank[py] -&gt; parent[py] = px
            rank[px] &lt; rank[py] -&gt; parent[px] = py
            else -&gt; {
                parent[px] = py
                rank[px]++
            }
        }
        return true
    }
}
</code></pre>
<p>把行、列有相同情况的元素union在一起，每个组都会留下一个元素，因此我们能有拿走的石头的最大数量就是 石头的数量 减去 并查集组的数量（与之前朋友圈的题目相似）。这里我们使用了一个 <strong>TypedUFS</strong> 来处理非int类型的源数据，map每次分配一个新元素一个新的Key值，最大程度的减少 <strong>parent</strong> 与 <strong>rank</strong> 数组的长度（最大只需要数据源的长度，而非数据源的范围，与Solution的区别）</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://zxi.mytechroad.com/blog/data-structure/sp1-union-find-set/">花花LeetCode</a><br>
<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">wiki</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search]]></title>
        <id>https://hakuless.github.io/post/binary-search</id>
        <link href="https://hakuless.github.io/post/binary-search">
        </link>
        <updated>2019-05-23T08:05:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<h4 id="what-is-binary-search">What is Binary Search</h4>
<p>Binary Search is one of the most fundamental and useful algorithms in Computer Science. It describes the process of search ing for a specific value in an ordered collection.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<h4 id="what-is-binary-search">What is Binary Search</h4>
<p>Binary Search is one of the most fundamental and useful algorithms in Computer Science. It describes the process of search ing for a specific value in an ordered collection.</p>
<!-- more --> 
<blockquote>
<p>Terminology used in Binary Search</p>
<ul>
<li>Target - the value tha you are searching for</li>
<li>Index - the current location that you are searching</li>
<li>Left, Right - the indicies from which we use to maintain ouer search Space</li>
<li>Mid - the index that we use to apply a condition to determine if we should search left or right</li>
</ul>
</blockquote>
<h3 id="how-does-it-work">How does it work?</h3>
<p>In its simplest form, Binary Sarch operates ona contiguous sequence with a specified left and right index. This is called the Search Space. Binary Search maintains the left, right and middle indicies of the search space and compares the search target or applies the search condition to the middle value of the collection; if the condition is unsatisfied or values unequal, the half in which the target cannnot lie is eliminated and the search continues on the remaining half until it is successful. if the search ends with an empty half, the condition cannot be fulfilled and target is not found.</p>
<h3 id="binary-search-template-i">Binary Search Template I</h3>
<pre><code>int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left &lt;= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] &lt; target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left &gt; right
  return -1;
}
</code></pre>
<h3 id="binary-search-template-ii">Binary Search Template II</h3>
<pre><code>int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length;
  while(left &lt; right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] &lt; target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.length &amp;&amp; nums[left] == target) return left;
  return -1;
}
</code></pre>
<h3 id="binary-search-template-iii">Binary Search Template III</h3>
<pre><code>int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 &lt; right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] &lt; target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
</code></pre>
<h3 id="binary-search-template-analysis">Binary Search Template Analysis</h3>
<p>These 3 templates differ by their:</p>
<ul>
<li>left, mid, right index assignments</li>
<li>loop or recursive termination condition</li>
<li>necessity of post-processing</li>
</ul>
<h4 id="template-1-left-right">Template #1 <strong>(left &lt;= right)</strong></h4>
<ul>
<li>Most basic and elmentary form of Binary search</li>
<li>Search Condition can be determined without comparing to the element's neighbors (or use specific elements around it)</li>
<li>No post-precessing required becasuse at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found</li>
</ul>
<h4 id="template-2-left-right">Template #2 <strong>(left &lt; right)</strong></h4>
<ul>
<li>An advanced way to implement Binary Search.</li>
<li>Search Condition needs to access element's immediate right neighbor</li>
<li>Use element's right neighbor to determine if condition is met and decide whether to go left or right</li>
<li>Gurantees Search Space is at least 2 in size at each step</li>
<li>Post-processing required. Loop/Recursion ends when you hava 1 element left. Need to assess if the remaining element meets the condition.</li>
</ul>
<h4 id="template-3-left-1-right">Template #3 <strong>(left + 1 &lt; right)</strong></h4>
<ul>
<li>An alternative way to implement Binary Search</li>
<li>Search Condition needs to access element's immediate left and right neighbors</li>
<li>Use element's neighbors to determine if condition is met and decide whether to go left or right</li>
<li>Gurantees Search Space is at least 3 in size at each step</li>
<li>Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS初级学习]]></title>
        <id>https://hakuless.github.io/post/css-chu-ji-xue-xi</id>
        <link href="https://hakuless.github.io/post/css-chu-ji-xue-xi">
        </link>
        <updated>2019-05-16T02:24:37.000Z</updated>
        <summary type="html"><![CDATA[<p>学习一下CSS，前端要是连设计稿都无法实现，基本需求都满足不了~</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习一下CSS，前端要是连设计稿都无法实现，基本需求都满足不了~</p>
<!-- more -->
<h2 id="css语法">CSS语法</h2>
<h3 id="基本规则">基本规则</h3>
<p>CSS主要由两部分组成：选择器(selector) &amp; 声明(declarations)</p>
<pre><code>/* selector {property: value} */
h1 {color:red; font-size:14px;}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hakuless.github.io//post-images/1557976004501.png" alt="" loading="lazy"></figure>
<h3 id="样式表书写">样式表书写</h3>
<p>目前，主要采用内联样式表的书写方案</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  	&lt;h1 style=&quot;color:red; font-size:14px;&quot;&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="规则">@规则</h3>
<p>通过@开头，后接标识符<br>
目前用的比较多的是 @keyframes，通过定义关键帧实现动画效果</p>
<pre><code>/* @keyframes */
@keyframes slidein {
    from {
        margin-left: 100%;
        width: 300%;
    }

    to {
        margin-left: 0%;
        width: 100%;
    }
}
</code></pre>
<h2 id="css工作流程">CSS工作流程</h2>
<h3 id="页面渲染机制">页面渲染机制</h3>
<p>页面渲染主要以下5个步骤：</p>
<ol>
<li>处理HTML来创建DOM tree；</li>
<li>处理CSS来创建CSSOM tree；</li>
<li>根据DOM跟CSSOM来合并render tree；</li>
<li>根据render tree来布局；</li>
<li>绘制render tree。</li>
</ol>
<h3 id="css的工作流程">CSS的工作流程</h3>
<p><img src="https://hakuless.github.io//post-images/1557976033477.png" alt="" loading="lazy"><br>
<strong>重排</strong> 与 <strong>重绘</strong></p>
<h2 id="css逻辑属性">CSS逻辑属性</h2>
<h3 id="新旧逻辑属性对比">新旧逻辑属性对比</h3>
<p><img src="https://hakuless.github.io//post-images/1557976478759.png" alt="" loading="lazy"><br>
新旧逻辑对比图表如下：</p>
<table>
<thead>
<tr>
<th>旧的逻辑属性</th>
<th>新的逻辑属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>margin-top</td>
<td>margin-block-start</td>
</tr>
<tr>
<td>margin-right</td>
<td>margin-inline-end</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>margin-block-end</td>
</tr>
<tr>
<td>margin-left</td>
<td>margin-inline-start</td>
</tr>
<tr>
<td>border-top</td>
<td>border-block-start</td>
</tr>
<tr>
<td>border-right</td>
<td>border-inline-end</td>
</tr>
<tr>
<td>border-bottom</td>
<td>border-block-end</td>
</tr>
<tr>
<td>border-left</td>
<td>border-inline-start</td>
</tr>
<tr>
<td>padding-top</td>
<td>padding-block-start</td>
</tr>
<tr>
<td>padding-right</td>
<td>padding-inline-end</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>padding-block-end</td>
</tr>
<tr>
<td>padding-left</td>
<td>padding-inline-start</td>
</tr>
<tr>
<td>width</td>
<td>inline-size</td>
</tr>
<tr>
<td>height</td>
<td>block-size</td>
</tr>
</tbody>
</table>
<p>Y轴方向属性使用 <strong>block</strong>，X轴方向属性使用 <strong>inline</strong></p>
<h3 id="css定位">CSS定位</h3>
<table>
<thead>
<tr>
<th>旧的逻辑属性</th>
<th>新的逻辑属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>inset-block-start</td>
</tr>
<tr>
<td>bottom</td>
<td>inset-block-end</td>
</tr>
<tr>
<td>left</td>
<td>inset-inline-start</td>
</tr>
<tr>
<td>right</td>
<td>inset-inline-end</td>
</tr>
</tbody>
</table>
<pre><code>/* 旧的逻辑属性 */
.popup{
  position:fixed;  
  top:0;
  bottom:0;
  left:0;
  right:0;
}
/* 新的逻辑属性 */
.popup{
   position:fixed;
   inset-block-start:0;  /*top - in English*/
   inset-block-end:0;    /*bottom - in English*/
   inset-inline-start:0; /*left - in English*/
   inset-inline-end:0;   /*right - in English*/
}
/* 新的逻辑属性支持简写 */
.popup{
   position:fixed;
   inset:0 0 0 0;   /*top, right, bottom, left - in English*/
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1557977057594.png" alt="" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1557977069217.png" alt="" loading="lazy"></p>
<h2 id="css盒子模型">CSS盒子模型</h2>
<p>待补充</p>
<h2 id="css选择器">CSS选择器</h2>
<h3 id="基本选择器">基本选择器</h3>
<ol>
<li>类型选择器： 直接html标签，如 html {width: 100%;}</li>
<li>类选择器：html标签中class属性的值，如 .div {width: 100%;}</li>
<li>ID选择器：现在不咋用了，通过html标签的ID属性来选择</li>
<li>通用选择器：更不会用... 所有标签生效...</li>
<li>属性选择器：根据html标签里的属性选择？？？</li>
</ol>
<h3 id="组合选择器">组合选择器</h3>
<ol>
<li>空格：后代选择器，<strong>.a .b</strong> 所有后代都生效</li>
<li>
<blockquote>
<p>：子代选择器，<strong>.a &gt; .b</strong> 只在一级儿子生效</p>
</blockquote>
</li>
<li>~：后继选择器，<strong>.a ~ .b</strong> 弟弟选择器，哥哥不生效</li>
<li>+：直接后继选择器，<strong>.a + .b</strong> 能生效的第一个弟弟生效</li>
<li>|：命名空间选择器，<strong>.a | .b</strong> 与后代类似</li>
<li>||：列表选择器，直接无视，这辈子都不会用的</li>
</ol>
<h3 id="伪类-与-伪元素">伪类 与 伪元素</h3>
<p><strong>伪类</strong>：伪类是添加到选择器的关键字，指定要选择的元素的特殊状态，如 a:hover，鼠标悬停状态的效果</p>
<pre><code>// 语法
selector:pseudo-class {
  property: value;
}
</code></pre>
<p><strong>伪元素</strong>：伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。一个选择器中只能使用一个伪元素，如 a::after { content: &quot;→&quot;; } 在所有a类型后增加一个箭头元素</p>
<pre><code>// 语法
selector::pseudo-element {
  property: value;
}
</code></pre>
<h3 id="css函数">CSS函数</h3>
<ul>
<li>属性函数：attr()；</li>
<li>背景图片函数：linear-gradient()、radial-gradient()、conic-gradient()、repeating-linear-gradient()、repeating-radial-gradient()、repeating-conic-gradient()、image-set()、image()、url()、element()；</li>
<li>颜色函数：rgb()、rgba()、hsl()、hsla()、hwb()、color-mod()；</li>
<li>图形函数：circle()、ellipse()、inset()、polygon()、path()</li>
<li>滤镜函数：blur()、brightness()、contrast()、drop-shadow()、grayscale()、hue-rotate()、invert()、opacity()、saturate()、sepia()；</li>
<li>转换函数：matrix()、matrix3d()、perspective()、rotate()、rotate3d()、rotateX()、rotateY()、rotateZ()、scale()、scale3d()、scaleX()、scaleY()、scaleZ()、skew()、skewX()、skewY()、translate()、translateX()、translateY()、translateZ()、translate3d()；</li>
<li>数学函数：calc()、min()、max()、mixmax()、repeat()；</li>
<li>缓动函数：cubic-bezier()、steps()；</li>
<li>其他函数：counter()、counters()、toggle()、var()、 symbols()。<br>
<a href="https://www.w3cplus.com/css/css-functions.html">CSS函数说明</a></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://krissarea.gitee.io/blog/">鱼头的海上世界</a><br>
<a href="https://www.w3.org/TR/?tag=css">CSS W3C标准文档</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS MDN文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS语法学习]]></title>
        <id>https://hakuless.github.io/post/js-yu-fa-xue-xi</id>
        <link href="https://hakuless.github.io/post/js-yu-fa-xue-xi">
        </link>
        <updated>2019-05-09T03:41:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="generators">Generators</h2>
<h2 id="promise">Promise</h2>
<h2 id="asyncawait">Async/Await</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stack & DFS]]></title>
        <id>https://hakuless.github.io/post/stack-and-dfs</id>
        <link href="https://hakuless.github.io/post/stack-and-dfs">
        </link>
        <updated>2019-02-19T12:00:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="stack-dfs">Stack &amp; DFS</h3>
<p>Similar to BFS, <strong>Depth-First Search</strong> can also be used to find the path from the root node to the target node.</p>
<p>The first path you found in DFS is not always the shortest path.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="stack-dfs">Stack &amp; DFS</h3>
<p>Similar to BFS, <strong>Depth-First Search</strong> can also be used to find the path from the root node to the target node.</p>
<p>The first path you found in DFS is not always the shortest path.</p>
<!-- more -->
<h3 id="dfs-template-i">DFS - Template I</h3>
<h4 id="template-recursion">Template - Recursion</h4>
<pre><code>/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
</code></pre>
<h3 id="dfs-template-ii">DFS - Template II</h3>
<p>The advantage of the recursion solution is that it is easier to implement. However, there is a huge disadvantage: if the depth of recursion is too high, youwill suffer from <strong>stack overflow</strong>.  In that case, you might want to use BFS instead or implement DFS using an explicit stack.</p>
<pre><code>/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set&lt;Node&gt; visited;
    Stack&lt;Node&gt; stack;
    add root to stack;
    while (s is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArrayList.sort踩坑之旅]]></title>
        <id>https://hakuless.github.io/post/arraylistsort-cai-keng-zhi-lu</id>
        <link href="https://hakuless.github.io/post/arraylistsort-cai-keng-zhi-lu">
        </link>
        <updated>2018-04-09T13:18:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>相信大家经常会用到各种优惠券，如外卖、打车等场景，而其中优惠券的排序，需要按照多个维度来排序，比如：</p>
<ol>
<li>首先按照价格是否满足可用，所有可用的在最前面，不可用的在最后面</li>
<li>对于可用的优惠券，需要按照券本身的价格排序，越值钱的排序越在前面</li>
<li>对于价格相同的，需要按照过期时间排序，快过期排在前面</li>
<li>剩余顺序任意，即可以认为剩余其他属性不影响排序</li>
</ol>
<p>根据上述条件，对一个ArrayList进行排序，通过传入一个Comparator来实现，想当然的敲入了下面的代码... 按照价格是否满足可选等上述条件分别返回 -1 和 1。真正按照Comparator接口含义，返回int值含义分为3种，负数、0、正数，分别代表第一个参数小于、等于、大于第二个参数。</p>
<pre><code class="language-Java">Collections.sort(mCouponInfoList, new Comparator&lt;UserCouponInfo&gt;() {
    @Override
    public int compare(UserCouponInfo o1, UserCouponInfo o2) {
        boolean canSelect1 = o1.priceLimit &lt;= mTotalPrice;
        boolean canSelect2 = o2.priceLimit &lt;= mTotalPrice;

        // sort by three dimensions, can be selected, value &amp; end time
        if (canSelect1 &amp;&amp; !canSelect2) {
            return -1;
        } else if (canSelect2 &amp;&amp; !canSelect1) {
            return 1;
        } else if (o1.value &gt; o2.value) {
            return -1;
        } else if (o1.value &lt; o2.value) {
            return 1;
        } else if (o1.endTime &lt; o2.endTime) {
            return -1;
        } else {
            // 发生错误的位置 ❌
            return 1; 
        }
    }
});
</code></pre>
<p>直觉上，对于不关注的属性排序顺序无所谓，就在最后的 else 全部给了 return 1，对于一些数据会爆出crash：java.lang.IllegalArgumentException: Comparison method violates its general contract!</p>
<h2 id="解决">解决</h2>
<p>查询定位问题产生原因 &amp; 解决问题比较容易，直接查Google也能发现这个Crash Log的含义是Compare自己违反了自己的约定，即排序自身出现了冲突，产生了如 C &gt; A &gt; B &gt; C 这样的结果，显然这种是明显的异常。<br>
修复方案也十分的简单，只要对于不关心的属性return 0即可，即认为值相等，对于上述核心内容修改如下：</p>
<pre><code class="language-Java">// sort by three dimensions, can be selected, value &amp; end time
if (canSelect1 &amp;&amp; !canSelect2) {
    return -1;
} else if (canSelect2 &amp;&amp; !canSelect1) {
    return 1;
} else if (o1.value &gt; o2.value) {
    return -1;
} else if (o1.value &lt; o2.value) {
    return 1;
} else if (o1.endTime &lt; o2.endTime) {
    return -1;
} else if (o1.endTime &gt; o2.endTime) {
    return 1;
} else {
    return 0;
}
</code></pre>
<p>这样对于相等的元素，不会再有模棱两可问题，若是类似于上述数据源，则会得出数据 C = A = B = C，不会发生错误。</p>
<h2 id="原因">原因</h2>
<p>下面重头戏来了，让我们一起在源码的海洋里面探究下到底是什么样的执行过程 &amp; 数据源导致的这个问题！</p>
<blockquote>
<p>遇到问题不能浅尝辄止，深入探究，改变以往的作风！</p>
</blockquote>
<p>以下源码分析均基于Android SDK 26，不同版本可能会有些不一样，请注意~</p>
<h3 id="方法调用栈">方法调用栈</h3>
<p>对于API &gt; 25的，方法的实际调用栈是 Collections.sort -&gt; List.sort -&gt; Arrays.sort -&gt; TimSort.sort，看样子罪恶的核心就在这个TimSort中。看源码之前，真的不清楚TimSort是个什么sort，通过查看网上文章 &amp; 源码才知道，TimSort是 归并排序（mergeSort）&amp; 插入排序（Insert）的一种混合使用，关于其详细含义不在这里赘述。</p>
<pre><code class="language-Java">static&lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, 
                    T[] work, int workBase, int workLen) {
    assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;

    int nRemaining  = hi - lo;
    if (nRemaining &lt; 2)
        return;  // Arrays of size 0 and 1 are always sorted

    // If array is small, do a &quot;mini-TimSort&quot; with no merges
    if (nRemaining &lt; MIN_MERGE) {
        int initRunLen = countRunAndMakeAscending(a, lo, hi, c);
        binarySort(a, lo, hi, lo + initRunLen, c);
        return;
    }

    /**
     * March over the array once, left to right, finding natural runs,
     * extending short natural runs to minRun elements, and merging runs
     * to maintain stack invariant.
     */
    TimSort&lt;T&gt; ts = new TimSort&lt;&gt;(a, c, work, workBase, workLen);
    int minRun = minRunLength(nRemaining);
    do {
        // Identify next run
        int runLen = countRunAndMakeAscending(a, lo, hi, c);

        // If run is short, extend to min(minRun, nRemaining)
        if (runLen &lt; minRun) {
            int force = nRemaining &lt;= minRun ? nRemaining : minRun;
            binarySort(a, lo, lo + force, lo + runLen, c);
            runLen = force;
        }

        // Push run onto pending-run stack, and maybe merge
        ts.pushRun(lo, runLen);
        ts.mergeCollapse();

        // Advance to find next run
        lo += runLen;
        nRemaining -= runLen;
    } while (nRemaining != 0);

    // Merge all remaining runs to complete sort
    assert lo == hi;
    ts.mergeForceCollapse();
    assert ts.stackSize == 1;
}
</code></pre>
<p>看一下TimSort的sort方法，排序长度小于1的直接返回，无需排序，对于长度小于MIN_MERGE（当前环境为32），先用countRunAndMakeAscending预处理，然后用二分查找插入排序，这个过程中两个数只会比较一次，并不会引发上述crash的内容，因此目标应该是在后面，对于大量数据拆分。<br>
其实通过crash log也能定位到，这个异常是在TimSort的 mergeLo &amp; mergeHi 方法中抛出，如下图：	<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fq5grlrdc1j318u04q759.jpg" alt="" loading="lazy"></p>
<h3 id="算法流程">算法流程</h3>
<h4 id="countrunandmakeascending">countRunAndMakeAscending</h4>
<p>首先，通过countRunAndMakeAscending方法，将整个数组变为划分为多个升序 or 降序的片段，每个片段是一个Run，对于降序的将其通过reverseRange将其转换为升序，核心代码如下图：<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fq5h2udmcrj319i0au76s.jpg" alt="" loading="lazy"><br>
如：{1, 3, 2, 10, 5, 4, 1} 会发生3次分片<br>
{1, 3}正常升序 {2, 10}正常升序 {1, 4, 5}降序被reverse成为升序</p>
<h4 id="mergecollapse-mergeforcecollapse">mergeCollapse &amp; mergeForceCollapse</h4>
<p>将Run放到一个栈结构中，并对相邻的Run进行merge操作。<br>
先举个最简单的例子，数组123454321的排序流程如下，先分Run片段，再merge。<br>
{1, 2, 3, 4, 5}<br>
{1, 2, 3, 4, 5}, {1, 2, 3, 4}<br>
{1, 1, 2, 2, 3, 3, 4, 4, 5}</p>
<p>问题就发生在这个merge的过程中，首先这个merge过程并不是入个栈就merge的，它有个条件如下图：<br>
<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fq5ifn2e30j313a0fw0v0.jpg" alt="" loading="lazy"></p>
<ol>
<li>只对相邻的区块merge</li>
<li>若当前区块数 &gt;= 3，If X &lt;= Y + Z，若 X &gt;= Z, 则将 Y 和 Z merge，否则 合并 X 和 Y</li>
<li>若当前区块数仅为 2，If X&lt;= Y，将 X 和 Y merge</li>
<li>不满足则等待下一个Run入栈，直到完全没有入栈数据，则用mergeForceCollapse强制merge所有Run（这里仍然有通过长度不同选择顺序的逻辑）</li>
</ol>
<p>上述流程如下图所示：<br>
<img src="https://ws4.sinaimg.cn/large/006tNc79gy1fq9ybsclcwj31cg0jo3zl.jpg" alt="" loading="lazy"><br>
发生问题的核心原因就是在merge的过程中，罪魁祸首在比较顺序的不统一，并不一直是index小的比较index大的，在 mergeHi &amp; mergeLo 中通过计算count的赢点，即要合并的数组中，你有多少比我最小值还小 or 比我最大值还大的。掐头去尾后，再次比较两个cursor，两个cursor都从大到小开始遍历，然后比较寻找插入的位置，然而在寻找这个插入位置时，compare(B[cursor2],A[cursor1])，因此会与compare(A[cursor1],B[cursor2])的结果不一致。</p>
<h4 id="bug产生详解">bug产生详解</h4>
<p>详细举例说明：两个数组A、B 分别是{1，3，3，5，7，10} 和 {3，8，12，15}，首先进行掐头去尾，如下图：<br>
<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fq6enhy0r6j3120054mxa.jpg" alt="" loading="lazy"><br>
A中的<strong>1</strong>和B中的<strong>15</strong>都是无需比较的，而这里两边3的比较是按照compare(B[0], A[1])比较的，由于代码的错误导致没有比较出相等，而是比较为小于，因此3被保留。正常情况应该应该一直将A中的两个3也掐掉，对于相等的处理是A中的掐头掐掉，B的去尾去掉。下面我们将这两个错误的3标红表示正常情况下不该保留。</p>
<blockquote>
<p>注：掐头去尾过程也是二分法比较寻找到需要的offset</p>
</blockquote>
<p>让我们继续，下面开始进行merge排序，两个cursor分别指向A、B的尾部，比较后插入。<br>
<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fq6f4d9z64j30wi0act90.jpg" alt="" loading="lazy"><br>
这个过程中，我们会认为A中最小的元素要大于B中最小的元素（因为掐头的原因），merge的过程中不断的移动cursor1和cursor2直到cursor1到头，然后就可以将B中剩余的元素全部移入A的头部即可完成排序。但是，当比较到两边3的过程时，由于比较顺序的变化，会把B中的3插入到A[2]位置，当cursor1再次移动时，查找B发现B已经空了，这不符合预想“A中最小的元素要大于B中最小的元素”，应该A先空，B后空才正确，因此JDK中主动throw了我们遇到的Exception。<br>
<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fq6fmu2w7zj31060eswfh.jpg" alt="" loading="lazy"><br>
由于compare的错误写法，导致A的cursor未遍历到头部就完成了merge，B中的元素全部被插入到A里了，这与开始的<strong>掐头去尾</strong>有明显的冲突，最后应该剩余1个or多个元素，再一起copy到A的头部才是正常的结果。</p>
<p>一顿凌乱的JDK代码，最后因优化减少比较次数，发生了这个问题，具体代码实在太乱了... JDK的还不好调试... 最后还是要感谢前辈们踩的坑，不然这个问题细节的研究还会多花一些时间...</p>
<p>最终结论，并不是只要有相等的元素就会crash，而是对分Run片有一定要求，需要比较顺序发生不一致的场景才有可能发生。<br>
<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fq5k488ttkj315o040gmh.jpg" alt="" loading="lazy"></p>
<h4 id="crash数据">Crash数据</h4>
<p>数组：{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,1,0,-2,0,0,0,0};<br>
排序接口实现：</p>
<pre><code class="language-Java">if (o1 &gt; o2) {
    1
} else {
    -1
}
</code></pre>
<h2 id="thanks-to">Thanks to</h2>
<p><a href="http://blog.2baxb.me/archives/993">图解JDK7的Comparison method violates its general contract异常</a><br>
<a href="https://blog.csdn.net/shadow_zed/article/details/72758912">crash数据</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2017年终总结]]></title>
        <id>https://hakuless.github.io/post/2017-nian-zhong-zong-jie</id>
        <link href="https://hakuless.github.io/post/2017-nian-zhong-zong-jie">
        </link>
        <updated>2018-02-13T07:47:58.000Z</updated>
        <summary type="html"><![CDATA[<p>2017算是毕业之后过的最Happy的一年了，没有别的原因，就是终于有点小钱了..</p>
]]></summary>
        <content type="html"><![CDATA[<p>2017算是毕业之后过的最Happy的一年了，没有别的原因，就是终于有点小钱了..</p>
<!--more-->
<h2 id="生活">生活</h2>
<h3 id="玩">玩</h3>
<p>生活虽然不是一团糟，但个人方面还是没什么进步。健身也没有坚持住，Keep就5月到10月... 之后虽然也有和<a href="http://alighters.com/">大佬</a> &amp; 雨霏老师等人一起去打羽毛球，但还是像<strong>老实</strong>说的 “运动量不够啊”。本年度还是要加强运动，当然该玩玩（该玩还是要玩的简称）... 像今年在羽毛球风盛行之前的台球风，还有跟雨霏老师、师母一起滑冰，还有保龄球（上一次打估计要追溯到在大庆跟高中同学一起打了），看看今年能不能跟<strong>老实</strong>一起去打打篮球。</p>
<h3 id="购物">购物</h3>
<p>购物方面，提倡极简，全年扔了两拨衣服，基本把不穿的衣服都扔了。买衣服基本就靠H&amp;M、优衣库了，买的总数量不要多，可以买稍微贵点的（这两家最贵的也就几百... 除了羽绒服等 特点的东西可能1000多点...）。米家有品上也买些家居用品，就是这个电暖气出的太晚了...你要入冬前 or 刚入冬就出我肯定会买.. 这都2月多了你才出... 今年也算不冷静了，买了trackpad、QC35二代（结合HHKB &amp; MBP15 算是集齐了），以为股票赚那么多，该花点钱享受下。这刚买完就...（提高生活质量，还是不要在乎这点小钱）</p>
<p>今年打算看看OnePlus6 &amp; 新的iPad，之前的iPad Air用了多年，一直是我看动画、漫画的利器，无奈当初没钱买的16G的，现在很是吃紧啊，要是再买一定买128的！</p>
<h3 id="食">食</h3>
<p>吃的方面，不得不提一嘴的就是<strong>石二锅</strong>撤出上海... 有的朋友知道，我来上海吃的第一顿饭就是<strong>杨大神</strong>请的石二锅，纪念价值不提，本身我也非常喜欢吃，经常周末<strong>一个人</strong>（划重点）去吃这个小火锅，一个人来个肉兜兜套餐，满足一天.. 工作餐也在阶段性的变化，三个月70后、3个月上官雪、3个月皇帝大...</p>
<blockquote>
<p>ps:石二锅的海鲜酱油是在上海吃过最好的</p>
</blockquote>
<p>吃了人生中最贵的一顿日料，浦发七夕1777刷卡金请客真是爽，这运气有雨霏老师的一半~</p>
<h3 id="行">行</h3>
<p>旅游的话，终于时隔N年之后再次来了一发，第一次离开大陆去香港。果然国际化是大陆城市没法比（虽然感觉可能上海更舒服），大马路上外国人的比例高到以为自己在其他国家。虽然没有买什么东西，不过还是逛了逛，吃了很多当地美食，点评也到具体商家签个到（终于不是mock的了！）。遗憾没有啥用英语跟外国人交流的机会，今年要加强日语学习，争取今年去趟日本玩一玩~</p>
<h2 id="工作-学习">工作 &amp; 学习</h2>
<p>在公司的业务开发稳定进行，也增长了很多 <strong>开发</strong>&amp;<strong>开发之外</strong>项目管理的经验，未来要做的更好。</p>
<h3 id="工程师思维">工程师思维</h3>
<p>在<strong>大佬</strong>和<strong>阿日</strong>来了之后，越发觉得自己在这方面的不足。遇到问题之后，解决问题的方案总是思考哪个方案更快、更简单，对于哪种更好则思考的过少，问题解决后也没有复盘思考有没有更好的方案。后期也有意识的多去思考些这方面的东西，比如自己的<a href="https://github.com/HakuLess/Holo">Holo</a>项目以及近期做的静态资源检查等。需要多读书，多看blog，争取做到以下：</p>
<ol>
<li>依靠技术手段来解决遇到的问题</li>
<li>不断优化解决方案</li>
</ol>
<h3 id="技术学习">技术学习</h3>
<ul>
<li>Kotlin，Kotlin和AnkoLayout用的真是爽</li>
<li>Freeline、Android打包流程、Gradle语法</li>
<li>ruby、python、nodeJs也都各写了点东西，最后还是主玩python吧，不要贪多（而且Python对Tensorflow的支持最好）</li>
</ul>
<p>此外，也踩了不少Android的坑，比如<a href="http://hakuless.github.io/2017/05/02/Android%E5%8A%A0%E8%BD%BD%E5%A4%A7%E5%9B%BE%E7%9A%84%E5%BC%82%E5%B8%B8/">Android加载大图的异常</a>，<a href="http://hakuless.github.io/2017/06/22/Vivo%E6%89%8B%E6%9C%BA%E4%B8%ADNumberPicker%E8%B8%A9%E5%9D%91%E8%AE%B0/">Vivo手机中NumberPicker踩坑记</a>，<a href="http://hakuless.github.io/2017/12/12/Android-Camera%E8%B8%A9%E5%9D%91%E8%AF%A6%E8%A7%A3/">Android Camera踩坑详解</a>...  还有个HashMap顺序的问题.. 在Android 8.0和之前版本的遍历顺序变化，还让我贡献了个线上故障...</p>
<p>今年的目标主要2点吧：</p>
<ol>
<li>作为Android开发，Android技术肯定第一位的。期待能用Kotlin开发公司的项目！</li>
<li>人工智能风很大，学习机器学习、TensorFlow</li>
</ol>
<h3 id="理财学习">理财学习</h3>
<p>作为一个理财小白，之前只会把所有的钱都扔到余额宝里，并且无任何信用卡。来了之后遇到很多卡神，教授了非常多的理财知识，感谢各位大佬。2017买了人生中第一支股票，也学习了许多股票相关知识，关注了几个讲理财相关的公众号。自己也准备写点代码来分析分析数据。虽然经历了本轮的美股大跌，但还是涨了很多经验，“浮亏那能叫亏么！”</p>
<ol>
<li>有了招行白Young入门，然后直接就上浦发AE白，建行龙卡... 薅羊毛还是很少的，短期不增加了</li>
<li>办理了香港银行卡，总资产也有40%左右是美元&amp;港币，算是初步的配置吧，接下来继续学习吧</li>
</ol>
<h2 id="娱乐篇">娱乐篇</h2>
<p>单独一章来看看2017被看完的漫画、小说</p>
<h3 id="完结小说">完结小说</h3>
<ul>
<li>孺子帝 （顾慎为、慕行秋，这回再+韩孺子）</li>
<li>大明妖孽（结尾不够轰轰烈烈，但是挺有味道，狐生鬼养胡桂扬）</li>
<li>择天记（结尾略...）</li>
</ul>
<p>我看小说都是按作者来的，目前只可着3个作者的看 猫腻、冰临神下 &amp; 混沌盘古</p>
<ol>
<li>猫腻的作品都看过，挺多人认为《间客》or《庆余年》是最好的，但我个人最喜欢《将夜》</li>
<li>冰临神下是最近两年一直在追的，首先冰大的更新几乎是风雨无阻，每日2更、周日1更，全年很少有断的（这就碾压了99%的作者），写的可不是三少那种小白文，2分钟一章的，每一章都可以仔细品读，会发现很多内容。每个人物都有血有肉，顾慎为、慕行秋、韩孺子、胡桂扬</li>
<li>盘子的女儿系列每个都看过，最喜欢的当属《魔王奶爸》，梦想很多次能把魔王奶爸 动漫化该有多好，不知道过个10年20年啥的能否看到希望~ 最近的系列《律政奶爸》没有在追，想等多出出再看...盘子的追更还是很难受的，就像柯南红与黑系列10多集每周追的话感觉要疯...</li>
</ol>
<h3 id="完结漫画">完结漫画</h3>
<ul>
<li>山田和七个魔女（结婚的狗粮 😭）</li>
<li>温罗太郎（腰斩的难受，螺旋卷钩生之后就喜欢上这种画风了）</li>
<li>在地狱边缘呐喊（迷上了Ella这种坚强的女性）</li>
<li>饥肠辘辘的玛丽（又一个腰斩，为啥~ 这么好看~）</li>
<li>虫奉行（大作，决战打的真久）</li>
<li>妖精的尾巴（战斗不够有策略，END的梗还可以）</li>
<li>吞噬人间（断断续续的... 剧情都快忘了.. 脑电波啊）</li>
<li>旋风管家（我的天啊，这个竟然有主线，还会完结！）</li>
<li>铁风（最近喜欢格斗漫画了，拳愿阿修罗 和 刃牙系列 都在追，这个女性主角的也很好看）</li>
<li>诚如神之所说（又一个断了挺久的，剧情有点忘，不过各种死亡游戏还是很好看、很烧脑）</li>
<li>伪恋（其实我是妹妹党的）</li>
<li>无间双龙（久闻大名，一直没有看，一波看完的感觉就是爽）</li>
<li>魂环（神作，三生三世算什么！七生七世才是起点）</li>
<li>LAST GAME（狗粮中个人认为能排进前3的，还有一个要留给我会长大人）</li>
<li>黑（小女孩 和 黑猫）</li>
<li>四月是你的谎言（看完动画才看的漫画，两者质量都是相当的高，看一次哭一次）</li>
<li>超智游戏（这智商，打棒球能把整个联盟都赢走）</li>
</ul>
<p>部分短篇就不说了，还有一些不推荐看的... 虽然我看完了...</p>
<ul>
<li>赤赫血物语（这结局我都无语了，这正派反派反转的.. 作者到底经历了啥）</li>
<li>刻命魔像（原本好好地，这都不是腰斩，是直接被暗杀了）</li>
</ul>
<blockquote>
<p>动漫是戒不了了，这辈子都戒不掉了！</p>
</blockquote>
<p>目前仍有很多好动画正在追，如 银魂、魔法使的新娘、龙王的工作（萝莉控必看），动漫估计会跟我一辈子了！<br>
漫画在追的更多，全写上的话基本上本文就不用干别的了，只提一个吧《GrandBlue碧蓝之海》，这个搞笑程度可以排第一了!大半夜的看，看得我乐出了声，根本停不下来啊！</p>
<h2 id="总结">总结</h2>
<p>今年要做的事：</p>
<ol>
<li>健身 &amp; 锻炼（不像大佬那样要求 八块腹肌，至少争取13x开头，现在154有点胖啊）</li>
<li>读书（之前总是自己胡思乱想很多，读书太少，应该多读些书，金融or管理方面）</li>
<li>学习 Android &amp; TensorFlow</li>
<li>接着赚钱</li>
</ol>
<p>今天是2018.02.13，明天情人节坐飞机回家... 后天就是大年三十...<br>
新的一年还是没想找女朋友（也没有不想找！！）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Freeline修改笔记]]></title>
        <id>https://hakuless.github.io/post/freeline-xiu-gai-bi-ji</id>
        <link href="https://hakuless.github.io/post/freeline-xiu-gai-bi-ji">
        </link>
        <updated>2017-12-25T02:37:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>美团点评合并后，许多业务线的客户端开发需要在 <strong>大众点评</strong> &amp; <strong>美团</strong>（甚至更多）的App上进行开发，而其中很可能有很多业务是重复的，如果通过copy代码不利于以后的修改，因此许多业务线使用提取子BU的公共业务库来解决该问题。</p>
<p>目前，因为海外团队需要跨地域（北京、上海）协作共同开发该复用库，且点评、美团的迭代周期也有差异，所以只要通过flavor打有一定差异的代码才能满足自己的迭代不会受到对方的影响。</p>
<p>而对我来说最蛋疼不过的就是Freeline（0.8.8）不支持子module有falvor，而看到freeline的issue和mr也有人提出相应的问题及代码，所以决定本地开搞一个兼容该情况的<strong>Freeline</strong>！😜</p>
<h2 id="工作流程">工作流程</h2>
<h3 id="不支持什么">不支持什么？</h3>
<p>首先，先让我们看下什么都不做的情况下用Freeline build会有什么问题，执行一下py freeline.py -d，发现编译不过会报错.. 截图如下：<br>
<img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuqhg299j30vi0d6js4.jpg" alt="" loading="lazy"></p>
<p>详细的看下，会发现是许多资源（可以包括java代码、xml和图片等）找不到，追其原因是flavor是按文件夹打包。比如打dianping渠道，会打包dianping和main文件夹，而meituan则会打meituan和main文件夹，对于这种Freeline的现状就只会打main文件夹... 所以只要flavor文件夹里有必要的内容就build不起来了.. 😂</p>
<h3 id="如何修改">如何修改？</h3>
<p>万能的gayhub上有许多大神潜伏者，<a href="https://github.com/alibaba/freeline/pull/857">https://github.com/alibaba/freeline/pull/857</a>，这里就是其中解决的PR，具体详细的解决原因后面再说，现在先说下这个该如何使用。</p>
<p>目前（2017.12.25），freeline官方还没有合入这个PR，因此无法通过官方的gradle插件解决该问题，那么我们只好自己build自己的freeline插件了！主要分为以下几步，每步都会详细的介绍~</p>
<ol>
<li>fork freeline or 直接clone freeline</li>
<li>修改代码，增加flavor支持</li>
<li>使用gradlew install使插件build到本地库中</li>
<li>修改自己项目中引入freeline的插件</li>
<li>修改初始化后的python代码</li>
<li>愉快的使用freeline build</li>
</ol>
<h4 id="代码修改">代码修改</h4>
<ul>
<li>修改groovy代码，具体diff只有一行 <a href="https://github.com/alibaba/freeline/pull/857/files#diff-4">https://github.com/alibaba/freeline/pull/857/files#diff-4</a>，只需要把module的flavor和buildtype传入即可，其余的工作可以直接交给python脚本即可</li>
<li>而由于我们需要发布到本地的maven库，为防止与freeline官方混淆，可以修改版本号 or 包名，我采用的方案是把版本号改成0.8.9（截至目前还未发布）</li>
<li>修改版本号一共两部分，1是gradle.porperties中的，2是build.gradle发布中的，如下图所示：<br>
<img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsvgkwshyj30x407iq37.jpg" alt="" loading="lazy"><br>
<img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsvh8m0dzj30x40auglw.jpg" alt="" loading="lazy"></li>
</ul>
<h4 id="本地发布">本地发布</h4>
<p>修改好代码后，我们需要将gradle插件发布到本地，在freeline工程根目录执行./gradlew install，执行完成后你就会发现你的插件发布在本地maven的仓库中了。对于mac来说路径在~/.m2隐藏文件夹下，并且版本号是你发布的版本号！<br>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsvlu520uj30u806qmxf.jpg" alt="" loading="lazy"></p>
<h4 id="修改项目">修改项目</h4>
<p>这回需要修改咱们自己的工程了~ 首先，如果你的build.gradle下的repositories如果没有mavenLocal请+一下，并且放在第一个，然后将你依赖中的freeline:gradle的版本改成你刚才build的版本（对我来说是0.8.9）</p>
<p>接下来，与正常直接引入freeline无差异，sync后执行./gradlew initFreeline -Pmirror，我这网不够好，用镜像能快不少... 执行完成后，会自动拉取官方freeline的python代码，你也可以修改gradle插件的下载路径，直接下载你将要修改的python，我是懒得发布... 就直接本地改吧，反正freeline更新频率还是很低的..</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsw1hkox5j31ju0r83zq.jpg" alt="" loading="lazy"><br>
在旧版本的项目信息中，modules只会包含name 和 path，而使用本地插件后，则会增加flavor和buildtype这两个属性，如下图所示：<br>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsw8aibobj31g20ogwfr.jpg" alt="" loading="lazy"></p>
<p>之后还要修改主工程根目录下freeline文件夹中的<strong>gradle_tools.py</strong>，具体diff参考<a href="https://github.com/alibaba/freeline/pull/857/files#diff-9">https://github.com/alibaba/freeline/pull/857/files#diff-9</a>，将flavor加入打包的资源路径，下面就可以执行python freeline.py -d -f了！</p>
<p>注意：如果你要修改打包渠道，需要执行一次python freeline.py -f，强制重新写一遍projectInfo，否则默认会用原来的配置进行增量编译。</p>
<p>在之后，就可以愉快的使用增量编译了，在一些超大App动辄编译一下5~10min都只要20s以内就可以搞定！</p>
<h3 id="为什么这么修改">为什么这么修改？</h3>
<p>其实，了解过Freeline源码的同学大概能明白Freeline的核心内容是什么。纯从代码的角度来看可分为python执行部分与gradle插件部分（当然还有自行改写的appt、dx等工具）。</p>
<p>之前，之所以没支持子module的flavor，主要是因为module资源的路径地址没有增加flavor文件夹，所以通过简单的传参，从gradle插件层 -&gt; python脚本层把flavor传过来即可。</p>
<h2 id="总结">总结</h2>
<p>本次算是第一个对gradle插件的开发流程稍有了解，接下来打算从零开发一个插件。开发插件与java开发module的技术栈还是有不少差异的~ 开启新的技能点！（如果可以的话，真想全职去搞Freeline 😁）</p>
]]></content>
    </entry>
</feed>