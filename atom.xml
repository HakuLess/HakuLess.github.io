<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hakuless.github.io/</id>
    <title>HaKuLess</title>
    <updated>2020-02-19T08:59:06.909Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hakuless.github.io/"/>
    <link rel="self" href="https://hakuless.github.io/atom.xml"/>
    <subtitle>ç²¾ç¥ç—…äººæ€è·¯å¹¿ï¼Œè„‘æ®‹å„¿ç«¥æ¬¢ä¹å¤š</subtitle>
    <logo>https://hakuless.github.io/images/avatar.png</logo>
    <icon>https://hakuless.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, HaKuLess</rights>
    <entry>
        <title type="html"><![CDATA[1340. Jump Game V â€”â€” é¢˜è§£]]></title>
        <id>https://hakuless.github.io/post/1340-jump-game-v-ti-jie</id>
        <link href="https://hakuless.github.io/post/1340-jump-game-v-ti-jie">
        </link>
        <updated>2020-02-19T08:43:50.000Z</updated>
        <summary type="html"><![CDATA[<p>Contest 174çš„Q4ï¼Œå¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œç”±äºåœ¨Contestä¸­è€—è´¹å¤§é‡ç²¾åŠ›å»æQ3çš„ DFS to BFSç»“æœå¯¼è‡´ä¸¤é“é¢˜éƒ½æ²¡æå®š... ï¼ˆè¿˜æ˜¯å¤ªå¹´è½»~ï¼‰<br>
Jump Gameç³»åˆ—ä¹Ÿæ¥åˆ°äº†ç¬¬äº”ä»£ï¼Œè¿™ä¸€ç³»åˆ—çš„é¢˜ç›®éƒ½å¾ˆç»å…¸ï¼Œè¦†ç›–äº†è´ªå¿ƒã€BFSã€DFSã€DPç­‰è®¸å¤šç®—æ³•ï¼Œä¸‹é¢è®©æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹è¿™ä¸ªç¬¬äº”ä»£å§</p>
]]></summary>
        <content type="html"><![CDATA[<p>Contest 174çš„Q4ï¼Œå¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œç”±äºåœ¨Contestä¸­è€—è´¹å¤§é‡ç²¾åŠ›å»æQ3çš„ DFS to BFSç»“æœå¯¼è‡´ä¸¤é“é¢˜éƒ½æ²¡æå®š... ï¼ˆè¿˜æ˜¯å¤ªå¹´è½»~ï¼‰<br>
Jump Gameç³»åˆ—ä¹Ÿæ¥åˆ°äº†ç¬¬äº”ä»£ï¼Œè¿™ä¸€ç³»åˆ—çš„é¢˜ç›®éƒ½å¾ˆç»å…¸ï¼Œè¦†ç›–äº†è´ªå¿ƒã€BFSã€DFSã€DPç­‰è®¸å¤šç®—æ³•ï¼Œä¸‹é¢è®©æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹è¿™ä¸ªç¬¬äº”ä»£å§</p>
<!-- more -->
<h3 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h3>
<p>ç»™å®šä¸€ä¸ªæ•´å‹æ•°ç»„arrå’Œä¸€ä¸ªæ•´æ•°dï¼Œæ•´å‹æ•°ç»„ä¸Šçš„ç‚¹ä»£è¡¨è¿™ä¸ªç‚¹æ‰€åœ¨çš„é«˜åº¦ï¼Œæ•´æ•°dä»£è¡¨äººèƒ½å¤Ÿç§»åŠ¨çš„æœ€å¤§æ¨ªå‘è·ç¦»ã€‚äººå¯ä»¥ä»æ•´å‹ä¸­çš„ä»»æ„ä¸€ä¸ªIndexå‡ºå‘ï¼Œåˆ°å¦ä¸€ä¸ªindexä¸Šï¼Œéœ€è¦æ»¡è¶³æ¡ä»¶ï¼š</p>
<ol>
<li>åªèƒ½åœ¨æ•°ç»„èŒƒå›´å†…ç§»åŠ¨ï¼Œå³æˆ‘ä»¬çš„indexåªèƒ½åœ¨æ•´å‹æ•°ç»„çš„indicesä¸­</li>
<li>å•æ­¥ç§»åŠ¨çš„æœ€å¤§è·ç¦»åªèƒ½æ˜¯dï¼Œå³ä»å½“å‰ç§»åŠ¨çš„èŒƒå›´æ˜¯[cur-d, cur+d]</li>
<li>ç§»åŠ¨ç›®æ ‡ åŠ ä¸å½“å‰ç›®æ ‡çš„ä¸­é—´å€¼ éƒ½è¦å°äºå½“å‰å€¼ï¼ˆäººåªèƒ½å‘ä¸‹è·³ï¼Œä¸èƒ½å‘ä¸Šçˆ¬ï¼‰<br>
æ±‚é—®ï¼Œäººæœ€å¤šèƒ½å¤Ÿç§»åŠ¨å‡ æ¬¡ï¼Ÿ<br>
<img src="https://hakuless.github.io//post-images/1582102355985.jpeg" alt="" loading="lazy"><br>
å¦‚ä¸Šå›¾æ‰€è¿°ï¼Œä»¥ä¸‹ä¸ºindexå€¼<br>
åœ¨d = 2æ—¶ï¼Œ10 -&gt; 8 -&gt; 6 -&gt; 7 å› æ­¤ç»“æœæ˜¯4<br>
åœ¨d = 3æ—¶ï¼Œ2 -&gt; 5 -&gt; 8 -&gt; 6 -&gt; 7 å› æ­¤ç»“æœæ˜¯5</li>
</ol>
<h3 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h3>
<ol>
<li>æŸä¸€Indexçš„æœ€ä¼˜è§£æ˜¯ä¸€å®šçš„ï¼Œä¸å› å…¶ä»–çŠ¶æ€è€Œæ”¹å˜</li>
<li>åŒæ—¶ï¼Œå½“å‰çŠ¶æ€çš„æœ€ä¼˜è§£ï¼Œå¯ä»¥ä¾èµ–äºé™„è¿‘æœ€å¤š2*dä¸ªçŠ¶æ€æ±‚è§£<br>
é€šè¿‡ä¸Šè¿°æ¡ä»¶ï¼Œå¯ä»¥å‘ç°ä¸€ä¸ªç²¾ç®€çš„è§£æ³•ï¼šDFS + Memo</li>
</ol>
<h3 id="è§£æ³•ä¸€dfs-memo">è§£æ³•ä¸€ï¼šDFS + Memo</h3>
<pre><code class="language-Kotlin">fun maxJumps(arr: IntArray, d: Int): Int {
    // åˆå§‹åŒ–DPæ•°ç»„ï¼Œå€¼ä»£è¡¨åœ¨indexä½ç½®ä¸Šçš„æœ€ä¼˜è§£ï¼Œ-1ä¸ºæœªæ±‚è§£çŠ¶æ€
    val dp = IntArray(arr.size) { -1 }
    for (i in 0..arr.lastIndex) {
        helper(arr, dp, i, d)
    }
    return dp.max()!!
}

private fun helper(arr: IntArray, dp: IntArray, cur: Int, d: Int): Int {
    // è‹¥å·²ç»æœ‰å€¼ï¼Œåˆ™ç›´æ¥è¿”å›ç»“æœï¼Œä¼˜åŒ–å­é—®é¢˜
    if (dp[cur] != -1) {
        return dp[cur]
    }
    // é»˜è®¤è‡ªå·±ä¸º1ï¼Œä»…èƒ½ç«™åœ¨è‡ªå·±çš„ä½ç½®ä¸Š
    dp[cur] = 1
    // å‘å‰è·³
    for (i in cur - 1 downTo cur - d) {
        if (i !in dp.indices)
            break
        // è‹¥ä¸­é—´é‡åˆ°æ›´é«˜çš„åˆ™åœæ­¢ï¼Œæ— æ³•è·³è·ƒ
        if (arr[i] &gt;= arr[cur]) {
            break
        }
        // æŸ¥æ‰¾å­é—®é¢˜
        dp[cur] = maxOf(dp[cur], helper(arr, dp, i, d) + 1)
    }
    // åŒç†å‘åè·³
    for (i in cur + 1..cur + d) {
        if (i !in dp.indices)
            break
        if (arr[i] &gt;= arr[cur]) {
            break
        }
        dp[cur] = maxOf(dp[cur], helper(arr, dp, i, d) + 1)
    }
    return dp[cur]
}
</code></pre>
<h3 id="è§£æ³•äºŒsort-dp">è§£æ³•äºŒï¼šSort + DP</h3>
<p>DPçš„åŠ¨æ€æ–¹ç¨‹å¤§å®¶æ¯”è¾ƒå¥½æƒ³ï¼Œé‚£å°±æ˜¯dp[i] = maxOf(dp[i - d..i + d] + 1)ï¼Œå…¶ä¸­ (i - d) ~ (i + d)éœ€è¦ç¬¦åˆä¸è·¨è¶Šç­‰é«˜oræ›´é«˜çš„valueï¼ŒåŒæ—¶è¦æ±‚è¿™äº›dpå€¼å·²ç»æ˜¯æ±‚å¥½çš„å€¼ã€‚<br>
é‚£ä¹ˆï¼Œæˆ‘ä»¬åªéœ€è¦ä»ä½åˆ°é«˜æ’åºåå†å»è®¡ç®—å°±èƒ½ä¿éšœéœ€è¦ç”¨åˆ°çš„å€¼ï¼Œè‚¯å®šæ˜¯å·²ç»ç®—å¥½äº†çš„ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-Kotlin">fun maxJumps(arr: IntArray, d: Int): Int {
    val sort = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;()
    arr.forEachIndexed { index, i -&gt;
        sort.add(Pair(index, i))
    }
    sort.sortBy { it.second }
    val dp = IntArray(arr.size) { -1 }
    sort.forEach {
        var max = 1
        for (i in it.first + 1..it.first + d) {
            if (i !in arr.indices || arr[i] &gt;= it.second) {
                break
            }
            // ç”±äºäº‹å…ˆæ’åºï¼Œè¿™é‡Œçš„dp[i]å¯ä»¥ä¿è¯éƒ½æ˜¯æœ‰æ•ˆçš„æ­£æ•°å€¼
            max = maxOf(max, 1 + dp[i])
        }
        for (i in it.first - 1 downTo it.first - d) {
            if (i !in arr.indices || arr[i] &gt;= it.second) {
                break
            }
            max = maxOf(max, 1 + dp[i])
        }
        dp[it.first] = max
    }
    return dp.max()!!
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1339. Maximum Product of Splitted Binary Tree â€”â€” é¢˜è§£]]></title>
        <id>https://hakuless.github.io/post/1339-maximum-product-of-splitted-binary-tree-ti-jie</id>
        <link href="https://hakuless.github.io/post/1339-maximum-product-of-splitted-binary-tree-ti-jie">
        </link>
        <updated>2020-02-10T07:43:50.000Z</updated>
        <summary type="html"><![CDATA[<p>Contest 174çš„Q3ï¼Œé—®é¢˜å¾ˆç®€æ´ï¼ŒæŠŠä¸€æ£µæ ‘åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œä½¿ä¸¤éƒ¨åˆ†çš„å’Œçš„ä¹˜ç§¯æœ€å°ï¼Œæ±‚è¿™ä¸ªæœ€å¤§å€¼ï¼ˆmod 10^9 + 7ï¼‰ï¼Œä¸è¿‡è¿™é¢˜å¯¹Kotlinå¾ˆä¸å‹å¥½ï¼Œä¸‹é¢ä¼šè¯¦è¿°</p>
]]></summary>
        <content type="html"><![CDATA[<p>Contest 174çš„Q3ï¼Œé—®é¢˜å¾ˆç®€æ´ï¼ŒæŠŠä¸€æ£µæ ‘åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œä½¿ä¸¤éƒ¨åˆ†çš„å’Œçš„ä¹˜ç§¯æœ€å°ï¼Œæ±‚è¿™ä¸ªæœ€å¤§å€¼ï¼ˆmod 10^9 + 7ï¼‰ï¼Œä¸è¿‡è¿™é¢˜å¯¹Kotlinå¾ˆä¸å‹å¥½ï¼Œä¸‹é¢ä¼šè¯¦è¿°</p>
<!-- more -->
<h3 id="åˆ†æé¢˜ç›®">åˆ†æé¢˜ç›®</h3>
<figure data-type="image" tabindex="1"><img src="https://hakuless.github.io//post-images/1581320864937.png" alt="" loading="lazy"></figure>
<ol>
<li>é¦–å…ˆæ•´æ£µæ ‘çš„å’Œæ˜¯ä¸€å®šçš„ï¼Œæ‹†åˆ†ä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯xï¼Œé‚£ä¹ˆå¦ä¸€éƒ¨åˆ†å°±æ˜¯ sum - xï¼Œå®ƒä»¬çš„ä¹˜ç§¯å°±æ˜¯ x * (sum - x)</li>
<li>æ‹†åˆ†ä¸¤éƒ¨åˆ†åï¼Œä¸€éƒ¨åˆ†æ˜¯ä»¥åŸæ¥çš„æ ¹ç»“ç‚¹ä¸ºæ ¹ï¼Œè€Œå¦ä¸€éƒ¨åˆ†åˆ™å¯èƒ½æ˜¯ä»¥åŸæ¥ä»»ä¸€ç‚¹ä¸ºæ ¹èŠ‚ç‚¹</li>
</ol>
<h3 id="è§£æ³•ä¸€dfs">è§£æ³•ä¸€ï¼šDFS</h3>
<p>é€šè¿‡ä¸Šè¿°æè¿°ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³åˆ°è§£æ³•ï¼Œé€šè¿‡DFSéå†ç®—å‡ºæ¯ä¸ªç‚¹åŒ…å«çš„å­èŠ‚ç‚¹çš„æ€»å’Œï¼Œç®—å‡ºå¦‚æœä»¥è‡ªå·±ä¸ºæ–°æ ‘çš„æ ¹ï¼Œæ‰€æ±‚çš„ç»“æœæ˜¯å¤šå°‘ï¼Œç„¶åæ±‚å‡ºå®ƒä»¬ä¸­çš„æœ€å¤§å€¼å³å¯</p>
<pre><code class="language-Kotlin">var max = 0L
val mod = 1000000007

fun maxProduct(root: TreeNode?): Int {
    val sum = dfs(root)
    helper(root, sum)
    return (max % mod).toInt()
}

private fun dfs(root: TreeNode?): Int {
    if (root == null) {
        return 0
    }
    return root.`val` + dfs(root.left) + dfs(root.right)
}

private fun helper(root: TreeNode?, sum: Int): Long {
    if (root == null) {
        return 0
    }
    val left = helper(root.left, sum)
    val right = helper(root.right, sum)
    max = maxOf(max, left * (sum - left))
    max = maxOf(max, right * (sum - right))
    return root.`val` + left + right
}
</code></pre>
<h4 id="é‡åˆ°çš„å‘">é‡åˆ°çš„å‘</h4>
<p>å½“æˆ‘ä»¬æŠŠä¸Šè¿°ä»£ç ç²˜åˆ°LeetCodeé‡Œå¹¶æäº¤åï¼Œä¼šå‘ç°æŸä¸ªCaseæŠ¥äº†StackOverflow... çœ‹æ ·å­æ ˆä¸å¤Ÿæ·±ï¼Œä½†æ˜¯å½“Contestç»“æŸåï¼Œçœ‹äº†ä¸‹å…¶ä»–äººçš„æäº¤ï¼ˆç”¨Java or Pythonï¼‰ä½¿ç”¨çš„æ–¹æ³•éƒ½æ˜¯ç±»ä¼¼çš„... è¿™å°±æ‚²å‰§äº†...</p>
<p>äºæ˜¯ï¼Œè®©æˆ‘ä»¬æµ‹è¯•ä¸‹LeetCodeä¸Šçš„Javaæ ˆä¸Kotlinæ ˆæ·±åº¦åšä¸ªæ¯”è¾ƒ</p>
<ol>
<li>é¦–å…ˆä¸ŠJavaä»£ç </li>
</ol>
<pre><code class="language-Java">public int maxProduct(TreeNode root) {
    dfs(0);
    return 0;
}

public void dfs(int a) {
    System.out.println(a);
    dfs(a + 1);
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1581322913478.png" alt="" loading="lazy"><br>
2. å†è®©æˆ‘ä»¬çœ‹çœ‹Kotlinä»£ç </p>
<pre><code class="language-Kotlin">fun maxProduct(root: TreeNode?): Int {
    test(0)
    return 0
}

fun test(l: Int) {
    println(l)
    test(l + 1)
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1581321912617.png" alt="" loading="lazy"><br>
ç»“æœå¦‚ä¸Šå›¾ï¼Œå¯ä»¥çœ‹å‡ºKotlinçš„æ–¹æ³•æ ˆæ·±åº¦çº¦ä¸º9000ï¼Œé‚£å½“æ ‘çš„æ·±åº¦è¶…è¿‡9000åŸºæœ¬å°±GGäº†... è€ŒJavaçš„æŠ¥é”™ç«Ÿç„¶éƒ½ä¸æ˜¯StackOverFlowè€Œæ˜¯TLEï¼ŒåŸºæœ¬ä¸ŠJavaæ ˆå°±æ˜¯æ— é™...</p>
<h3 id="è§£æ³•äºŒbfs">è§£æ³•äºŒï¼šBFS</h3>
<p>æ´»äººä¸èƒ½è®©å°¿æ†‹æ­»ï¼Œæ—¢ç„¶Kotlinçš„DFSä¸è¡Œï¼Œé‚£æˆ‘ä»¬å°±æ”¹æˆBFSï¼Œä»ä¸‹åˆ°ä¸Šä¸€å±‚ä¸€å±‚çš„éå†ï¼ŒåŒæ—¶è®°å½•æ¯ä¸ªItemçš„Parentï¼Œéå†ç›¸åŠ ï¼Œä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-Kotlin">var max = 0L
val mod = 1000000007
val map = HashMap&lt;TreeNode, Int&gt;()
private val parent = HashMap&lt;TreeNode, TreeNode&gt;()

fun maxProduct(root: TreeNode?): Int {
    var sum = 0
    val queue: Queue&lt;TreeNode?&gt; = LinkedList()
    queue.add(root)
    val all = ArrayList&lt;TreeNode&gt;()
    while (queue.isNotEmpty()) {
        val size = queue.size
        for (i in 0 until size) {
            val item = queue.poll()
            if (item != null) {
                all.add(item)
                if (item.left != null) {
                    parent[item.left!!] = item
                    queue.offer(item.left)
                }
                if (item.right != null) {
                    parent[item.right!!] = item
                    queue.offer(item.right)
                }
                sum += item.`val`
            }
        }
    }

    all.forEach {
        map[it] = it.`val`
    }

    all.reversed().forEach {
        val item = it
        if (parent.containsKey(item)) {
            map[parent[item]!!] = map[parent[item]!!]!! + map[item]!!
        }
    }

    map.forEach {
        max = maxOf(max, it.value.toLong() * (sum - it.value))
    }
    return (max % mod).toInt()
}
</code></pre>
<p>è¿™ä¸ªæ˜æ˜¾è¦æ¯”DFSå¤æ‚äº›ï¼ŒContestçš„æ—¶å€™æäº†åŠå¤©ï¼Œç»“æœQ4éƒ½æ²¡æ¥å¾—åŠåš... æ‚²å‰§å•Š... è·ŸLeetCodeå®˜æ–¹å‘ä¸ªé‚®ä»¶çœ‹èƒ½ä¸èƒ½å¤„ç†ä¸‹Kotlinçš„è¿™ä¸ªé—®é¢˜...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1326. Minimum Number of Taps to Open to Water a Garden â€”â€” é¢˜è§£]]></title>
        <id>https://hakuless.github.io/post/1326-minimum-number-of-taps-to-open-to-water-a-garden-ti-jie</id>
        <link href="https://hakuless.github.io/post/1326-minimum-number-of-taps-to-open-to-water-a-garden-ti-jie">
        </link>
        <updated>2020-02-03T06:17:18.000Z</updated>
        <summary type="html"><![CDATA[<p>Contest 172 Q4ï¼Œä½œä¸ºå‹è½´é¢˜é¢˜ç›®ä¸ç®—å¤ªéš¾ï¼Œåšçš„æ—¶å€™æé”™äº†ç‚¹ä¸çº¿æ®µï¼Œç„¶ååœ¨é”™è¯¯çš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œ...<br>
é™„åŸé¢˜é“¾æ¥<a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/">Minimum Number of Taps to Open to Water a Garden</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Contest 172 Q4ï¼Œä½œä¸ºå‹è½´é¢˜é¢˜ç›®ä¸ç®—å¤ªéš¾ï¼Œåšçš„æ—¶å€™æé”™äº†ç‚¹ä¸çº¿æ®µï¼Œç„¶ååœ¨é”™è¯¯çš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œ...<br>
é™„åŸé¢˜é“¾æ¥<a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/">Minimum Number of Taps to Open to Water a Garden</a></p>
<!-- more -->
<h3 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h3>
<p>ä¸€ä¸ªä¸€ç»´çš„çº¿æ®µç»„æˆçš„èŠ±å›­ï¼Œçº¿æ®µä¸Šæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªæ°´é¾™å¤´ï¼Œç»™å‡ºæ¯ä¸ªæ°´é¾™å¤´èƒ½æµ‡çš„èŒƒå›´ï¼Œé—®æœ€å°‘èƒ½ç”¨å‡ ä¸ªæ°´é¾™å¤´è¦†ç›–æ•´ä¸ªèŠ±å›­ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š<br>
<img src="https://hakuless.github.io//post-images/1580714329749.png" alt="" loading="lazy"><br>
èŠ±å›­èŒƒå›´æ˜¯[0..5]ï¼Œç»™å‡ºæµ‡ç›–èŒƒå›´æ˜¯[3,4,1,1,0,0]<br>
æ°´é¾™å¤´0èƒ½è¦†ç›–[0..3]<br>
æ°´é¾™å¤´1èƒ½è¦†ç›–[0..5]<br>
æ°´é¾™å¤´2èƒ½è¦†ç›–[1..3]<br>
æ°´é¾™å¤´3èƒ½è¦†ç›–[3..4]</p>
<ul>
<li>è´Ÿæ•°åŠå¤§äº5çš„æ•°ä¸ç”¨è€ƒè™‘</li>
<li>èŒƒå›´æ˜¯0åˆ™åªæ˜¯ä¸€ä¸ªç‚¹ï¼Œå¯ä»¥ç›´æ¥ä¸çœ‹</li>
</ul>
<h3 id="é¢˜ç›®è§£æ">é¢˜ç›®è§£æ</h3>
<ol>
<li>è¦†ç›–çš„æ˜¯èŒƒå›´ï¼Œå› æ­¤å¦‚æœæŸä¸ªæ°´é¾™å¤´èŒƒå›´æ˜¯0ï¼Œåˆ™æ— æ•ˆï¼ˆè‡³å°‘è¦1ï¼‰</li>
<li>ç»“æœåªè¦æ±‚æ°´é¾™å¤´çš„æ•°é‡ï¼Œå¯¹ä½¿ç”¨å“ªäº›ä¸å…³å¿ƒï¼Œç›´è§‰ä¸Šä½¿ç”¨æš´åŠ›è´ªå¿ƒ</li>
<li>æ•°æ®èŒƒå›´æ˜¯ 1 &lt;= n &lt;= 10^4ï¼Œå¤æ‚åº¦ä½¿ç”¨O(nÂ²)ä¼°è®¡ä¹Ÿå¯ä»¥è¿‡</li>
</ol>
<h3 id="è§£æ³•ä¸€-æš´åŠ›è´ªå¿ƒ">è§£æ³•ä¸€ æš´åŠ›è´ªå¿ƒ</h3>
<ol>
<li>è®¾ç½®pä¸º å½“å‰å¿…é¡»è¦è¢«æµ‡åˆ°çš„ç‚¹ï¼ˆå³pä¹‹å‰å·²ç»è¢«æµ‡åˆ°äº†ï¼Œä»0å¼€å§‹ï¼‰</li>
<li>qä¸ºè¦†ç›–åˆ°å½“å‰æµ‡åˆ°çš„ç‚¹çš„æ°´é¾™å¤´èƒ½åˆ°è¾¾çš„æœ€è¿œè·ç¦»</li>
<li>æ¯æ¬¡å¾ªç¯å®Œæˆï¼Œå°†qèµ‹å€¼ç»™pï¼ˆæ³¨æ„ï¼Œè¿™é‡Œæ˜¯éœ€è¦è¿ç»­çš„ï¼Œå³æµ‡ã€4, 6ã€‘åå¿…é¡»è¦ã€6, nã€‘è€Œä¸æ˜¯ã€7, nã€‘ï¼Œå› ä¸ºã€6, 7ã€‘ä¹‹é—´çš„åœŸåœ°éƒ¨åˆ†ï¼Œæˆ‘ä»¬æµ‡çš„ä¸æ˜¯ç‚¹è€Œæ˜¯è¿ç»­çš„çº¿æ®µï¼‰</li>
<li>å¦‚æœpèµ°åˆ°äº† &gt;= nï¼Œä»£è¡¨å½“å‰é€‰æ‹©çš„æ•°é‡å·²è¶³å¤Ÿè¦†ç›–åˆ°æ•´ä¸ªèŠ±å›­ï¼Œç›´æ¥returnå³å¯</li>
<li>å¦‚æœæŸæ¬¡å¾ªç¯p == qï¼Œä»£è¡¨å½“å‰å·²ç»æ²¡æœ‰è¿›æ­¥ç©ºé—´äº†...ä¸‹ä¸€æ®µæ²¡æœ‰ä»»ä½•æ°´é¾™å¤´èƒ½æµ‡åˆ°ï¼Œå› æ­¤ç›´æ¥return -1</li>
<li>æ—¶é—´å¤æ‚åº¦ä¸º O(nÂ²)ï¼Œæ¯”è¾ƒæš´åŠ›çš„è§£æ³•ï¼Œç¬¬äºŒå±‚forå¾ªç¯æ˜¯ä»0åˆ°nçš„</li>
</ol>
<pre><code class="language-Kotlin">fun minTaps(n: Int, ranges: IntArray): Int {
    var p = 0
    var q = 0
    var res = 0
    while (p &lt; n) {
        for (i in 0..n) {
            if (i - ranges[i] &lt;= p) {
                q = maxOf(q, i + ranges[i])
            }
        }
        if (p == q) return -1
        p = q
        res++
    }
    return res
}
</code></pre>
<h3 id="è§£æ³•äºŒ-ä¼˜åŒ–è´ªå¿ƒ">è§£æ³•äºŒ ä¼˜åŒ–è´ªå¿ƒ</h3>
<ol>
<li>ä¸Šé¢çš„è§£æ³•æ˜¯åŒå±‚forå¾ªç¯å®Œæ•´éå†ï¼Œå¦‚æœå¯¹åŸå§‹æ•°æ®è¿›è¡Œæ’åºï¼Œå¯ä»¥åªéå†ä¸€æ¬¡</li>
<li>é¦–å…ˆå°†æ¯ä¸ªç‚¹èƒ½è¦†ç›–åˆ°çš„èŒƒå›´è®¡ç®—å‡ºintervalsåˆ—è¡¨</li>
<li>æŒ‰ç…§å·¦ä¾§è¿›è¡Œæ’åºï¼Œéå†çš„æ—¶å€™åªéœ€è¦ä¸€éå³å¯</li>
<li>å†…éƒ¨åŸç†ä¸ä¸Šè¿°ç›¸åŒï¼Œcurä»£è¡¨å½“å‰å¿…é¡»è¢«æµ‡çŒåˆ°çš„ç‚¹ï¼Œnextä¸ºå½“å‰è¦†ç›–curçš„åŒæ—¶èƒ½å¤Ÿè¦†ç›–æœ€è¿œçš„ç‚¹</li>
<li>æ—¶é—´å¤æ‚åº¦ ä¸º O(nlogn)</li>
</ol>
<pre><code class="language-Kotlin">fun minTaps(n: Int, ranges: IntArray): Int {
    val intervals = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;()
    for (i in 0..n) {
        intervals.add(Pair(i - ranges[i], i + ranges[i]))
    }
    intervals.sortBy { it.first }
    var ans = 0
    var cur = 0
    var next = 0
    var index = 0
    while (index &lt;= n) {
        val it = intervals[index]
        if (it.first &lt;= cur) {
            next = maxOf(next, it.second)
            index++
            if (next &gt;= n) {
                return ans + 1
            }
        } else {
            if (next == cur) {
                return -1
            }
            cur = next
            ans++
        }
    }
    return ans
}
</code></pre>
<h3 id="è§£æ³•ä¸‰-å†ä¼˜åŒ–è´ªå¿ƒ">è§£æ³•ä¸‰ å†ä¼˜åŒ–è´ªå¿ƒ</h3>
<p>ä¸Šè¿°è§£æ³•å› æ’åºè€Œä½¿äº‹ä»¶å¤æ‚åº¦å˜æˆO(nlogn)ï¼Œé‚£ä¹ˆå¦‚æœèƒ½å¤Ÿä¸é€‚ç”¨æ’åºåˆ™å¯ä»¥å†æ¬¡é™ä½æ—¶é—´å¤æ‚åº¦åˆ°O(n)</p>
<ol>
<li>æˆ‘ä»¬æ¥è®¾ç½®ä¸€ä¸ªé•¿åº¦ä¸ºn+1çš„æ•°ç»„boundsï¼Œbounds[i]ä»£è¡¨ä»¥iä¸ºèµ·ç‚¹èƒ½è¦†ç›–åˆ°çš„æœ€è¿œç‚¹</li>
<li>è®¾ç½®åˆå§‹æ¡ä»¶ï¼Œ0å¿…é¡»è¦†ç›–
<ol>
<li>ansä»1å¼€å§‹ï¼ˆå³è¦†ç›–0ï¼‰</li>
<li>å½“å‰ansæ‰€èƒ½è¦†ç›–åˆ°çš„æœ€å¤§å€¼cur</li>
<li>éå†åˆ°ç›®å‰ä¸ºæ­¢å¯èƒ½è¦†ç›–åˆ°çš„æœ€å¤§å€¼next</li>
</ol>
</li>
<li>ç„¶åéå†1..n
<ol>
<li>å¦‚æœindexå·²ç»è¶…å‡ºå¯èƒ½è¦†ç›–çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆ[index-1..index]ä¸­çš„éƒ¨åˆ†æ˜¯æ— æ³•è¢«è¦†ç›–åˆ°çš„ï¼Œç›´æ¥-1</li>
<li>å½“index&gt;cur &amp;&amp; index &lt;=nextæ—¶ï¼Œéœ€è¦æ–°å¼€ä¸€ä¸ªæ°´é¾™å¤´æ‰èƒ½è¦†ç›–indexï¼Œå¹¶ä¸”æ›´æ–°å½“å‰æœ€å¤§è·ç¦»</li>
<li>ä¸æ–­æ›´æ–°éå†åˆ°å½“å‰èƒ½è¦†ç›–åˆ°çš„æœ€å¤§å€¼</li>
</ol>
</li>
<li>å¯ä»¥çœ‹å‡ºï¼Œæ•´ä¸ªç®—æ³•äº‹ä»¶å¤æ‚åº¦ä¸ºO(n)ï¼Œå·§å¦™çš„åˆ©ç”¨æ•°ç»„å­˜å‚¨ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹èƒ½è¦†ç›–åˆ°çš„æœ€å¤§å€¼ &amp;&amp; éå†æ—¶ä¸æ–­æ›´æ–°nextå€¼ï¼Œè€Œé¿å…äº†æ’åºçš„è¿‡ç¨‹</li>
</ol>
<pre><code class="language-Kotlin">fun minTaps(n: Int, ranges: IntArray): Int {
    val bounds = IntArray(n + 1)
    ranges.forEachIndexed { index, it -&gt;
        val left = maxOf(0, index - it)
        val right = minOf(n, index + it)
        bounds[left] = right
    }
    var ans = 1
    var cur = bounds[0]
    var next = bounds[0]

    for (i in 1..n) {
        if (i &gt; next) return -1
        if (i &gt; cur) {
            ans++
            cur = next
        }
        if (bounds[i] &gt; next) {
            next = bounds[i]
        }
    }
    return ans
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1114. Print in Order â€”â€” é¢˜è§£]]></title>
        <id>https://hakuless.github.io/post/1114-print-in-order-ti-jie</id>
        <link href="https://hakuless.github.io/post/1114-print-in-order-ti-jie">
        </link>
        <updated>2020-02-03T03:32:34.000Z</updated>
        <summary type="html"><![CDATA[<p>æœ€è¿‘å·¥ä½œä¸­ç»ˆäºæœ‰äº›å¤šçº¿ç¨‹çš„Caseäº†ï¼Œç©ä¸€ç©LeetCodeå¤šçº¿ç¨‹çš„é¢˜ç›®ï¼Œå¤ä¹ ä¸€ä¸‹çŸ¥è¯†ï¼ˆNä¹…æ²¡æœ‰å¼€å‘è¿‡å¤šçº¿ç¨‹äº¤äº’çš„ä»£ç äº†...ï¼‰<br>
é™„ä¸Šé¢˜ç›®é“¾æ¥ <a href="https://leetcode.com/problems/print-in-order/">Print in Order</a>ğŸ˜</p>
]]></summary>
        <content type="html"><![CDATA[<p>æœ€è¿‘å·¥ä½œä¸­ç»ˆäºæœ‰äº›å¤šçº¿ç¨‹çš„Caseäº†ï¼Œç©ä¸€ç©LeetCodeå¤šçº¿ç¨‹çš„é¢˜ç›®ï¼Œå¤ä¹ ä¸€ä¸‹çŸ¥è¯†ï¼ˆNä¹…æ²¡æœ‰å¼€å‘è¿‡å¤šçº¿ç¨‹äº¤äº’çš„ä»£ç äº†...ï¼‰<br>
é™„ä¸Šé¢˜ç›®é“¾æ¥ <a href="https://leetcode.com/problems/print-in-order/">Print in Order</a>ğŸ˜</p>
<!-- more -->
<h3 id="åŸé¢˜æè¿°">åŸé¢˜æè¿°</h3>
<p>ç»™å®šä¸€ä¸ªå¦‚ä¸‹çš„ç±»Fooï¼ŒABCä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«è°ƒç”¨ firstã€secondã€thirdæ–¹æ³•ï¼Œä½†æ˜¯æ— è®ºABCçš„è°ƒç”¨é¡ºåºå¦‚ä½•ï¼Œæˆ‘ä»¬çš„è¾“å‡ºé¡ºåºä¿æŒç€1ã€2ã€3</p>
<pre><code class="language-Kotlin">public class Foo {
Â  public void first() { print(&quot;first&quot;); }
Â  public void second() { print(&quot;second&quot;); }
Â  public void third() { print(&quot;third&quot;); }
}
</code></pre>
<h3 id="å˜ç§">å˜ç§</h3>
<p>ç”±äºLeetCodeä¸Šçš„å¤šçº¿ç¨‹é¢˜ç›®ä¸æ”¯æŒKotlinä»£ç ï¼Œå› æ­¤è‡ªå·±è®¾ç½®ä¸»å‡½æ•° å¹¶ ç¨å¾®æ”¹å˜ä¸‹é¢˜ç›®ï¼Œæ–¹ä¾¿è§‚å¯Ÿç»“æœ<br>
é¦–å…ˆï¼Œæˆ‘ä»¬æŠŠä¸»å‡½æ•°è®¾ç½®ä¸ºå¦‚ä¸‹ä»£ç ï¼š</p>
<pre><code class="language-Kotlin">fun main(args: Array&lt;String&gt;) {
    val max = 1000
    val s = Foo()
    thread {
        for (i in 0..max)
            s.first()
    }
    thread {
        for (i in 0..max)
            s.second()
    }
    thread {
        for (i in 0..max)
            s.third()
    }
}
</code></pre>
<ol>
<li>å…±æœ‰ä¸‰ä¸ªä¸åŒçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹è‡ªå·±ä¼šå»æ‰§è¡ŒFooçš„firstã€secondã€thirdæ–¹æ³•å„1001æ¬¡</li>
<li>æˆ‘ä»¬å¸Œæœ›æ‰“å°firstå…ˆæ‰§è¡Œï¼Œç„¶åæ‰§è¡Œsecondï¼Œå†æ‰§è¡Œthird(å¾ªç¯åå¤)</li>
<li>æœ€ç»ˆæ¯ä¸ªæ‰“å°éƒ½1001æ¬¡ï¼Œå…±è®¡3003æ¬¡</li>
</ol>
<h3 id="è§£æ³•ä¸€countdownlatch">è§£æ³•ä¸€ï¼šCountDownLatch</h3>
<ol>
<li>åˆ†åˆ«è®¾ç½®ä¸‰ä¸ªä¸åŒçš„CountDownLatchï¼Œåˆ†åˆ«æ‹¦æˆªfirstã€secondã€third</li>
<li>æœ€å¼€å§‹firstä¸ç”¨æ‹¦æˆªï¼Œé»˜è®¤è®¾ç½®c0ä¸º0</li>
<li>æ‰§è¡Œè‡ªå·±æ—¶ï¼Œå°†ä¸‹ä¸€é“é—¨countDownæ‰ï¼ˆæ¯ä¸ªæ‰§è¡Œéƒ½åˆ°ç­‰å¾…è‡ªå·±çš„é—¨ï¼‰</li>
<li>æ‰§è¡Œå®Œæˆè‡ªå·±ï¼Œé‡æ–°æŠŠè‡ªå·±çš„é—¨é—©è®¾ç½®ä¸Šï¼ˆé˜²æ­¢é‡å¤æ‰§è¡ŒæŸä¸€ä¸ªï¼‰</li>
</ol>
<pre><code class="language-Kotlin">class Foo {
    private var c0 = CountDownLatch(0)
    private var c1 = CountDownLatch(1)
    private var c2 = CountDownLatch(1)

    fun first() {
        c0.await()
        println(&quot;first&quot;)
        c0 = CountDownLatch(1)
        c1.countDown()
    }

    fun second() {
        c1.await()
        println(&quot;second&quot;)
        c1 = CountDownLatch(1)
        c2.countDown()
    }

    fun third() {
        c2.await()
        println(&quot;third&quot;)
        c2 = CountDownLatch(1)
        c0.countDown()
    }
}
</code></pre>
<h3 id="è§£æ³•äºŒ-reentrantlock-with-condition">è§£æ³•äºŒï¼š ReentrantLock with Condition</h3>
<ol>
<li>ä½¿ç”¨å˜é‡curï¼Œä»£è¡¨å½“å‰å…è®¸æ‰§è¡Œçš„æ–¹æ³•</li>
<li>é¦–å…ˆåœ¨firstã€secondã€thirdä¸­éƒ½åŠ å…¥lock()å’Œunlock()ï¼Œä¿è¯æ¯æ¬¡åªä¼šæœ‰ä¸€ä¸ªæ–¹æ³•æ‰§è¡Œ</li>
<li>æ‰§è¡Œæ—¶è¿›è¡Œå˜é‡åˆ¤æ–­ï¼Œæ ¹æ®æ¡ä»¶æ‰§è¡Œæ‰“å° or condition.wait()</li>
<li>æ‰§è¡Œå®Œæˆåï¼Œä¿®æ”¹å˜é‡cur &amp;&amp; æç¤ºä¸‹ä¸€ä¸ªconditionå¯ä»¥æ‰§è¡Œ</li>
</ol>
<pre><code class="language-Kotlin">class Foo {

    private val lock = ReentrantLock()

    var cur = 1
    private val c1 = lock.newCondition()
    private val c2 = lock.newCondition()
    private val c3 = lock.newCondition()

    fun first() {
        lock.lock()
        if (cur != 1) {
            c1.await()
        }
        println(&quot;first&quot;)
        cur = 2
        c2.signal()
        lock.unlock()
    }

    fun second() {
        lock.lock()
        if (cur != 2) {
            c2.await()
        }
        println(&quot;second&quot;)
        cur = 3
        c3.signal()
        lock.unlock()
    }

    fun third() {
        lock.lock()
        if (cur != 3) {
            c3.await()
        }
        println(&quot;third&quot;)
        cur = 1
        c1.signal()
        lock.unlock()
    }
}
</code></pre>
<h3 id="è§£æ³•ä¸‰-objecté”-wait-notify">è§£æ³•ä¸‰ï¼š Objecté” &amp; wait &amp; notify</h3>
<p>è¯¥æ–¹æ³•ç›´æ¥åˆ©ç”¨Objectç±»ä¸­çš„waitæ–¹æ³•ï¼ˆç”±äºKotlinä¸­çš„Anyå¹¶æ²¡æœ‰ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨aså¼ºè½¬ä¸€ä¸‹ï¼‰åœä½çº¿ç¨‹</p>
<ol>
<li>é€šè¿‡ @Synchronized æ³¨è§£ä½¿ä¸‰ä¸ªæ–¹æ³•äº’æ–¥</li>
<li>åŒæ ·è®¾ç½®curä¸ºå½“å‰å¯æ‰§è¡Œçš„æ–¹æ³•å˜é‡</li>
<li>é€šè¿‡whileå¾ªç¯åˆ¤æ–­æ˜¯å¦å¯æ‰§è¡Œï¼Œä¸å¯æ‰§è¡Œåˆ™waitï¼Œå¯æ‰§è¡Œåˆ™æ‰§è¡Œå¹¶notifyAll</li>
</ol>
<p>æ³¨ï¼š</p>
<ol>
<li>è¿™é‡Œéœ€è¦ç”¨whileåˆ¤æ–­ï¼Œè€Œéè§£æ³•äºŒä¸­çš„ifåˆ¤æ–­ï¼Œä¸»è¦æ˜¯notifyAllä¼šå”¤é†’å…¶ä»–æ‰€æœ‰çš„waitï¼Œè€Œwaitå”¤é†’åæ˜¯ç»§ç»­æ‰§è¡Œï¼Œå¦‚æœä½¿ç”¨ifåˆ™æœ‰å¯èƒ½æ¡ä»¶ä»ä¸åŒ¹é…ï¼Œä½†æ˜¯æ‰§è¡Œä¸‹å»ï¼Œå¯¼è‡´ä¸è¦æ±‚ä¸ç¬¦</li>
<li>å¯ä»¥çœ‹å‡ºè§£æ³•ä¸‰ä¸å¦‚1ã€2çš„æ§åˆ¶ç²¾å‡†ï¼Œèƒ½å¤Ÿå”¤é†’ç‰¹å®šçº¿ç¨‹</li>
</ol>
<pre><code class="language-Kotlin">class Foo {
    var cur = 1

    @Synchronized
    fun first() {
        while (cur != 1) {
            (this as Object).wait()
        }
        println(&quot;first&quot;)
        cur = 2
        (this as Object).notifyAll()
    }

    @Synchronized
    fun second() {
        while (cur != 2) {
            (this as Object).wait()
        }
        println(&quot;second&quot;)
        cur = 3
        (this as Object).notifyAll()
    }

    @Synchronized
    fun third() {
        while (cur != 3) {
            (this as Object).wait()
        }
        println(&quot;third&quot;)
        cur = 1
        (this as Object).notifyAll()
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1105. Filling Bookcase Shelves â€”â€” é¢˜è§£]]></title>
        <id>https://hakuless.github.io/post/1105-filling-bookcase-shelves-ti-jie</id>
        <link href="https://hakuless.github.io/post/1105-filling-bookcase-shelves-ti-jie">
        </link>
        <updated>2019-07-03T07:19:48.000Z</updated>
        <summary type="html"><![CDATA[<p>æœ¬å‘¨çŠ¶æ€ä¸é”™ï¼Œå¯æƒœå¥½å‡ å‘¨æ²¡æœ‰DPçš„é¢˜ï¼Œä¸€ä¸‹å¡ä½äº†...<br>
<a href="https://leetcode.com/problems/filling-bookcase-shelves/">https://leetcode.com/problems/filling-bookcase-shelves/</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>æœ¬å‘¨çŠ¶æ€ä¸é”™ï¼Œå¯æƒœå¥½å‡ å‘¨æ²¡æœ‰DPçš„é¢˜ï¼Œä¸€ä¸‹å¡ä½äº†...<br>
<a href="https://leetcode.com/problems/filling-bookcase-shelves/">https://leetcode.com/problems/filling-bookcase-shelves/</a></p>
<!-- more -->
<h3 id="é¢˜ç›®å¤§æ„">é¢˜ç›®å¤§æ„</h3>
<p>ç»™å‡ºä¸€ç»„ä¹¦ï¼Œä¹¦æœ‰å®½ã€é«˜ï¼Œæ¶å­ä¹Ÿæœ‰å®½åº¦ï¼ŒæŒ‰ç…§é¡ºåºä»ä¸Šå‘ä¸‹æ‘†æ”¾ï¼Œé—®æ¶å­è‡³å°‘éœ€è¦å¤šé«˜æ‰èƒ½æŠŠä¹¦éƒ½æ”¾å®Œï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š<br>
<img src="https://hakuless.github.io//post-images/1562138680833.png" alt="" loading="lazy"><br>
è¿™é‡Œéœ€è¦æ³¨æ„</p>
<ol>
<li>ä¹¦æ˜¯æŒ‰é¡ºåºæ”¾çš„ï¼Œæ‰€ä»¥4ã€5ã€6æ— æ³•æ”¾åˆ°1çš„å³ä¾§ï¼Œä¸å±äºè´ªå¿ƒ</li>
<li>æ¢è¡Œç­–ç•¥ï¼Œå¦‚2å¯ä»¥æ”¾åœ¨1çš„å³ä¾§ï¼Œä½†æ˜¯3å°±è¦å¦èµ·ä¸€è¡Œï¼Œç›¸å¯¹å ç”¨é«˜åº¦ä¼šæ›´å¤§</li>
</ol>
<h3 id="é¢˜è§£">é¢˜è§£</h3>
<p>ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£è¿™ç±» <strong>ä¸­é—´çŠ¶æ€</strong> &amp;&amp; <strong>ä¸‹ä¸€ä¸ªè¾“å…¥</strong> ç¡®å®š <strong>ä¸‹ä¸€ä¸ªçŠ¶æ€</strong> çš„é—®é¢˜<br>
æœ¬é¢˜ä¸­ï¼Œå¦‚æœæ²¡æœ‰7çš„è¾“å…¥ï¼Œé‚£ä¹ˆé«˜åº¦ä¼šæ˜¯5ï¼Œè€Œæˆä¸º6åŸå› æ˜¯å‰6ä¸ªè¾“å…¥çš„ç»“æœ<br>
ç¬¬7æœ¬ä¹¦å¯ä»¥ç‹¬ç«‹ä¸€è¡Œï¼Œor ä¸å‰è¾¹è¿ç»­çš„næœ¬ä¹¦ä¸€èµ·ä¸€è¡Œï¼ˆnä»0åˆ°6ï¼Œæ€»ä½“å®½åº¦ä¸å¯ä»¥å¤§äºæ¶å­å®½åº¦ï¼‰<br>
é‚£ä¹ˆ å‰6æœ¬ä¹¦çš„æœ€å°é«˜åº¦ä¹Ÿå¯ä»¥ä¾ç…§è¯¥é€»è¾‘æ±‚å‡ºï¼Œå³æ¯ä¸ªçŠ¶æ€ä¸‹çš„æœ€å°é«˜åº¦ï¼Œæœ€åå¾—å‡ºåŠ¨æ€æ–¹ç¨‹ä¸º</p>
<pre><code>// nä»0å–åˆ°K-1ï¼Œç›´åˆ°å®ƒä»¬æ€»å®½åº¦å¤§äºæ¶å­å®½åº¦
dp[k] = minOf[dp[k], dp[k-n] + max[height{k-n..k}]]
</code></pre>
<p>å…·ä½“é¢˜è§£ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-Kotlin">fun minHeightShelves(books: Array&lt;IntArray&gt;, shelf_width: Int): Int {
		val n = books.size
		val height = IntArray(n + 1)
		for (i in 0 until n) {
				var min = Int.MAX_VALUE
				var h = 0
				var w = 0
				for (j in i downTo 0) {
						h = maxOf(h, books[j][1])
						w += books[j][0]
						if (w &gt; shelf_width) break
						min = minOf(min, h + height[j])
				}
				height[i + 1] = min
		}
		return height[n]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Union-Find Set]]></title>
        <id>https://hakuless.github.io/post/union-find-set</id>
        <link href="https://hakuless.github.io/post/union-find-set">
        </link>
        <updated>2019-05-25T03:51:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>å¹¶æŸ¥é›†æ˜¯ä¸ªå¾ˆæœ‰æ„æ€çš„æ•°æ®ç»“æ„ï¼Œå®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯æŠŠä¸åŒçš„å…ƒç´  åˆ†ç»„ å¹¶ å…³è” èµ·æ¥ï¼Œèƒ½å¤Ÿåœ¨ O(1) æ—¶é—´å†…åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨ä¸€ç»„é‡Œã€‚å…³ç³»å…·æœ‰ä¼ é€’æ€§çš„é—®é¢˜ï¼Œéƒ½å¯ä»¥åˆ©ç”¨å¹¶æŸ¥é›†å¤„ç†ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>å¹¶æŸ¥é›†æ˜¯ä¸ªå¾ˆæœ‰æ„æ€çš„æ•°æ®ç»“æ„ï¼Œå®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯æŠŠä¸åŒçš„å…ƒç´  åˆ†ç»„ å¹¶ å…³è” èµ·æ¥ï¼Œèƒ½å¤Ÿåœ¨ O(1) æ—¶é—´å†…åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨ä¸€ç»„é‡Œã€‚å…³ç³»å…·æœ‰ä¼ é€’æ€§çš„é—®é¢˜ï¼Œéƒ½å¯ä»¥åˆ©ç”¨å¹¶æŸ¥é›†å¤„ç†ã€‚</p>
 <!-- more -->
<h2 id="function">function</h2>
<p>å¹¶æŸ¥é›†çš„æ ¸å¿ƒä¸»è¦æ˜¯ä¸¤ä¸ªæ–¹æ³•ï¼Œä¸€ä¸ªæ˜¯æŸ¥æ‰¾ <strong>find(x)</strong>ï¼Œé€šè¿‡ä¼ å…¥å…ƒç´ ï¼Œè¿”å›å…ƒç´ æ‰€åœ¨ç»„çš„Keyï¼ˆä¸åŒå…ƒç´ è¿”å›çš„Keyå€¼ç›¸åŒï¼Œä»£è¡¨è¿™äº›å…ƒç´ åœ¨åŒä¸€ç»„é‡Œï¼‰ã€‚å¦ä¸€ä¸ªæ˜¯ <strong>union(x, y)</strong>ï¼Œå°†ä¸¤ä¸ªä¸åŒçš„å…ƒç´ åˆå¹¶ä¸ºä¸€ç»„ï¼ŒåŒæ—¶å±äºè¿™ä¸¤ç»„çš„æ•°æ®éƒ½åœ¨ä¸€ä¸ªå¤§ç»„å†…ã€‚</p>
<pre><code>class UnionFindSet:
	func UnionFindSet(n):
		parents = [1..n]
		rank = [0..0] (n zeros)
	
	func Find(x):
		if x != parents[x]:
			parents[x] = Find(parents[x])
		return parents[x]
		
	func Union(x, y):
		px, py = Find(x), Find(y)
		if ranks[px] &gt; ranks[py]: parents[py] = px
		if ranks[px] &lt; ranks[py]: parents[px] = py
		if ranks[px] == ranks[py]
			parents[py] = px
			ranks[px]++
</code></pre>
<p>ä¸Šé¢æ˜¯ä¼ªä»£ç ï¼Œæ³¨æ„åˆ°æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š</p>
<ol>
<li>find(x) é€šè¿‡é€’å½’ä¸€ç›´å‘ä¸Šå¯»æ‰¾ï¼Œå¹¶ä¸æ–­çš„èµ‹å€¼</li>
<li>union(x, y)è¿‡ç¨‹ï¼Œä¼šæ ¹æ® rankså€¼è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åmergeæ–¹å¼ä¸åŒ</li>
</ol>
<h3 id="path-compression">Path Compression</h3>
<p>é¦–å…ˆï¼Œfindå¯»æ‰¾è¿‡ç¨‹ä¸­åŒæ—¶è¿›è¡Œ <strong>path compression</strong> ä¼˜åŒ–ï¼Œå¦‚å»ºç«‹å…³è”å…³ç³»æ—¶ï¼Œæ•´ä¸ªå…³è”å›¾çš„å…³ç³»éå¸¸çš„é•¿ï¼Œå¦‚ä¸‹å›¾ï¼š<br>
<img src="https://hakuless.github.io//post-images/1558768567180.png" alt="" loading="lazy"><br>
å½“æˆ‘ä»¬è¦æŸ¥æ‰¾1æ‰€åœ¨ç»„æ—¶ï¼Œä¼šä¸€ç›´éå†åˆ°é“¾è¡¨å¤´ï¼Œä¼šéå¸¸è€—æ—¶ï¼Œå› æ­¤éœ€è¦åœ¨findè¿‡ç¨‹ä¸­è¿›è¡Œä¼˜åŒ–ï¼ŒæŠŠ1ã€2ã€3ã€5ï¼ˆæŸ¥æ‰¾çš„æ•°æ®åŠå…¶æ‰€æœ‰ç¥–å…ˆï¼‰å‡ç›´æ¥æŒ‡å‘8ï¼ˆClass IDï¼‰ï¼Œæ‹‰å¹³æˆ‘ä»¬çš„æ ‘ç»“æ„ï¼ˆflatten the structureï¼‰ï¼Œå˜æˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š<br>
<img src="https://hakuless.github.io//post-images/1558768774411.png" alt="" loading="lazy"><br>
è¿™æ—¶å€™æˆ‘ä»¬å†æ¬¡æŸ¥æ‰¾æ—¶ï¼Œä¼šå¤§å¤§å‡å°‘éå†æ‰€éœ€æ—¶é—´</p>
<h3 id="union-by-rank">Union By Rank</h3>
<p>åˆå¹¶çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬é€šè¿‡Union By Rankæ¥è¿›è¡Œä¼˜åŒ–ï¼ŒåŸç†ä¸ä¸Šè¿°å†…å®¹ç±»ä¼¼ï¼Œå°±æ˜¯ä¸ºäº†å‡å°‘æˆ‘ä»¬æŸ¥æ‰¾è¿‡ç¨‹ä¸­çš„è€—æ—¶ã€‚ç”±äºæˆ‘ä»¬çš„mergeè¿‡ç¨‹å°±æ˜¯æŠŠä¸€ä¸ªç»„çš„æ ¹èŠ‚ç‚¹ç›´æ¥æŒ‡å‘å¦ä¸€ä¸ªç»„çš„æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¦‚æœæŠŠä¸€ä¸ªå¾ˆå¤æ‚çš„ç»“æ„+åˆ°ä¸€ä¸ªç®€å•ç»“æ„ä¸Šï¼Œä¼šå¢åŠ æ•´ä¸ªæ ‘çš„æ·±åº¦ï¼Œåä¹‹åˆ™ä¸ä¼šå¢å¤§å¤æ‚åº¦ã€‚å› æ­¤æˆ‘ä»¬å°½é‡è®©æ·±åº¦å°çš„æ ‘ attach åˆ°æ·±åº¦å¤§çš„æ ‘ä¸Šï¼Œæ•ˆæœå¦‚ä¸‹å›¾ï¼š<br>
<img src="https://hakuless.github.io//post-images/1558769263768.png" alt="ä¸¤ç»„è¿›è¡Œåˆå¹¶" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769351883.png" alt="å°æ ‘attachå¤§æ ‘" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769433973.png" alt="å¤§æ ‘attachå°æ ‘" loading="lazy"><br>
å¯ä»¥æ˜æ˜¾çœ‹å‡ºï¼Œå½“å¤§æ ‘attachå°æ ‘æ—¶ï¼Œå¤æ‚åº¦æ˜æ˜¾å¢åŠ ï¼Œé€šè¿‡ä¸€ä¸ªrankæ•°ç»„è®°å½•æ¯ä¸€æ¬¡åšæ·±èŠ‚ç‚¹çš„æ“ä½œï¼ˆRankå€¼ç›¸åŒçš„åˆå¹¶ï¼‰ï¼Œå¹¶ç”¨äºåˆ¤æ–­ä»¥åçš„unionæ“ä½œ</p>
<h2 id="leetcode">LeetCode</h2>
<h3 id="684-redundant-connection">684. Redundant Connection</h3>
<p>æ ‡å‡†çš„å¹¶æŸ¥é›†é¢˜ç›®ï¼Œç»™å‡ºä¸€ç»„æ— å‘å›¾çš„è¾¹ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä½¿æ— ç›¸åŒä¸­äº§ç”Ÿç¯çš„è¾¹ =&gt;<br>
è½¬åŒ–ä¸º å°†ç»™å‡ºçš„è¾¹ï¼ŒæŒ‰é¡ºåºæŠŠæ‰€æœ‰çš„ç‚¹è¿›è¡Œåˆ†ç»„ï¼Œç›´åˆ°å‘ç°æŸæ¡è¾¹åœ¨æ·»åŠ ä¹‹å‰ï¼Œè¾¹çš„ä¸¤ä¸ªç‚¹å°±å·²ç»åœ¨ä¸€ç»„é‡Œäº†ï¼Œé‚£ä¹ˆæ­¤æ—¶è‹¥åŠ å…¥è¿™æ¡è¾¹ï¼Œå³ä¼šäº§ç”Ÿç¯ã€‚</p>
<pre><code>class Solution {
    fun findRedundantConnection(edges: Array&lt;IntArray&gt;): IntArray {
        val dsu = DSU(edges.size)
        for (i in 0 until edges.size) {
            val x = edges[i][0] - 1
            val y = edges[i][1] - 1
            if (dsu.find(x) == dsu.find(y)) {
                return intArrayOf(x + 1, y + 1)
            }
            dsu.union(x, y)

        }
        return intArrayOf()
    }
}
</code></pre>
<h3 id="547-friend-circles">547. Friend Circles</h3>
<p>è¿™ä¸ªæ•°æ®æ›´ç›´æ¥çš„å¹¶æŸ¥é›†é¢˜ç›®ï¼Œä»¥äºŒç»´æ•°ç»„å½¢å¼ ç»™å‡ºä¸€ä¸ªç­çº§åŒå­¦ä¹‹é—´çš„æœ‹å‹å…³ç³»ï¼Œ1æ˜¯æœ‹å‹ 0ä¸æ˜¯ï¼ŒåŒæ—¶ æœ‹å‹çš„æœ‹å‹ä¹Ÿæ˜¯æœ‹å‹ï¼ˆ...ï¼‰ï¼Œç„¶åç»™å‡ºæ•´ä¸ªç­çº§ä¸€å…±æœ‰å¤šå°‘çš„æœ‹å‹åœˆã€‚ã€‚ã€‚</p>
<pre><code>class Solution {
    fun findCircleNum(M: Array&lt;IntArray&gt;): Int {
        val size = M.size
        val dsu = DSU(size)
        for (i in 0 until size) {
            for (j in 0 until size) {
                if (M[i][j] == 1 &amp;&amp; i != j) {
                    dsu.union(i, j)
                }
            }
        }

        val ans = HashSet&lt;Int&gt;()
        for (i in 0 until size) {
            ans.add(dsu.find(i))
        }
        return ans.size
    }
}
</code></pre>
<p>è¿™é‡Œå°†æ‰€æœ‰çš„å…³ç³»ï¼Œå½•å…¥åˆ°å¹¶æŸ¥é›†ä¸­ï¼Œç„¶åéå†æ‰€æœ‰çš„å­¦ç”Ÿæ‰€å±çš„ç»„æ”¾åˆ°Seté‡Œï¼Œé‚£ä¹ˆSetçš„é•¿åº¦å°±æ˜¯æœ‹å‹åœˆçš„æ•°é‡</p>
<h3 id="947-most-stones-removed-with-same-row-or-column">947. Most Stones Removed with Same Row or Column</h3>
<p>ä¸€èˆ¬å¹¶æŸ¥é›†çš„å¾®å˜å½¢ï¼Œä¸€ä¸ªäºŒç»´æ£‹ç›˜ä¸Šï¼Œæ•£è½ç€ä¸€å †çŸ³å¤´ï¼ˆæ¯ä¸ªçŸ³å¤´ä¸€ä¸ªç‚¹ ä¸” ä¸ä¼šæœ‰é‡å¤ï¼‰ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ä¸€æ¬¡ä¸€ä¸ªçš„å–ä¸‹çŸ³å¤´ï¼ˆå¯¹çŸ³å¤´æœ‰è¦æ±‚ï¼Œéœ€è¦æœ‰å…¶ä»–çŸ³å¤´å’Œå–ä¸‹çš„çŸ³å¤´åœ¨åŒä¸€è¡Œ or åŒä¸€åˆ—ï¼Œå³è‡ªå·±å•ç‹¬ä¸€è¡Œ &amp; ä¸€åˆ— çš„çŸ³å¤´æ— æ³•å–ä¸‹ï¼Œå¤©ç…å­¤çŸ³ï¼‰<br>
è¿™é‡Œï¼Œä¸€ç»„çš„å±æ€§æ˜¯ è¡Œæ•° or åˆ—æ•°ç›¸åŒï¼ŒSolutioné‡Œç»™å‡ºçš„æ–¹æ¡ˆæ˜¯æ ¹æ® <strong>Note</strong> ä¸­å…¥å‚çš„é™åˆ¶æ¥æŠŠ <em>åˆ—</em> è½¬æ¢ä¸º 10000+çš„ <em>è¡Œ</em> æ•°ï¼Œæˆ‘ä»¬è¿™é‡Œé‡‡ç”¨æ›´é€šç”¨çš„åŠæ³•ï¼Œé€šè¿‡ä¸€ä¸ªMapè½¬æ¢æˆ‘ä»¬çš„Class IDä¸æ•°æ®ï¼ˆIDä¸å±æ€§ä¸éœ€è¦æœ‰å¼ºå…³ç³»ï¼‰</p>
<pre><code>class Solution {
    fun removeStones(stones: Array&lt;IntArray&gt;): Int {
        val max = stones.size
        val ufs = TypedUFS&lt;IntArray&gt;(max)
        for (i in 0 until max) {
            for (j in i + 1 until max) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ufs.union(stones[i], stones[j])
                }
            }
        }

        val set = hashSetOf&lt;Int&gt;()
        stones.forEach {
            val root = ufs.typedFind(it)
            set.add(root)
        }

        return stones.size - set.size
    }
}

class TypedUFS&lt;T&gt;(var n: Int = 0) {
    val parent = IntArray(n) { i -&gt; i }
    val rank = IntArray(n)

    val map = hashMapOf&lt;T, Int&gt;()
    var total = 0

    fun typedFind(key: T): Int {
        var x = total
        if (map.containsKey(key)) {
            x = map[key]!!
        } else {
            map[key] = total
            total++
        }
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun find(x: Int): Int {
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun union(x: T, y: T): Boolean {
        val px = typedFind(x)
        val py = typedFind(y)
        if (px == py) {
            return false
        }
        when {
            rank[px] &gt; rank[py] -&gt; parent[py] = px
            rank[px] &lt; rank[py] -&gt; parent[px] = py
            else -&gt; {
                parent[px] = py
                rank[px]++
            }
        }
        return true
    }
}
</code></pre>
<p>æŠŠè¡Œã€åˆ—æœ‰ç›¸åŒæƒ…å†µçš„å…ƒç´ unionåœ¨ä¸€èµ·ï¼Œæ¯ä¸ªç»„éƒ½ä¼šç•™ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤æˆ‘ä»¬èƒ½æœ‰æ‹¿èµ°çš„çŸ³å¤´çš„æœ€å¤§æ•°é‡å°±æ˜¯ çŸ³å¤´çš„æ•°é‡ å‡å» å¹¶æŸ¥é›†ç»„çš„æ•°é‡ï¼ˆä¸ä¹‹å‰æœ‹å‹åœˆçš„é¢˜ç›®ç›¸ä¼¼ï¼‰ã€‚è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ª <strong>TypedUFS</strong> æ¥å¤„ç†éintç±»å‹çš„æºæ•°æ®ï¼Œmapæ¯æ¬¡åˆ†é…ä¸€ä¸ªæ–°å…ƒç´ ä¸€ä¸ªæ–°çš„Keyå€¼ï¼Œæœ€å¤§ç¨‹åº¦çš„å‡å°‘ <strong>parent</strong> ä¸ <strong>rank</strong> æ•°ç»„çš„é•¿åº¦ï¼ˆæœ€å¤§åªéœ€è¦æ•°æ®æºçš„é•¿åº¦ï¼Œè€Œéæ•°æ®æºçš„èŒƒå›´ï¼Œä¸Solutionçš„åŒºåˆ«ï¼‰</p>
<h2 id="å‚è€ƒèµ„æ–™">å‚è€ƒèµ„æ–™</h2>
<p><a href="https://zxi.mytechroad.com/blog/data-structure/sp1-union-find-set/">èŠ±èŠ±LeetCode</a><br>
<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">wiki</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search]]></title>
        <id>https://hakuless.github.io/post/binary-search</id>
        <link href="https://hakuless.github.io/post/binary-search">
        </link>
        <updated>2019-05-23T08:05:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<h4 id="what-is-binary-search">What is Binary Search</h4>
<p>Binary Search is one of the most fundamental and useful algorithms in Computer Science. It describes the process of search ing for a specific value in an ordered collection.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<h4 id="what-is-binary-search">What is Binary Search</h4>
<p>Binary Search is one of the most fundamental and useful algorithms in Computer Science. It describes the process of search ing for a specific value in an ordered collection.</p>
<!-- more --> 
<blockquote>
<p>Terminology used in Binary Search</p>
<ul>
<li>Target - the value tha you are searching for</li>
<li>Index - the current location that you are searching</li>
<li>Left, Right - the indicies from which we use to maintain ouer search Space</li>
<li>Mid - the index that we use to apply a condition to determine if we should search left or right</li>
</ul>
</blockquote>
<h3 id="how-does-it-work">How does it work?</h3>
<p>In its simplest form, Binary Sarch operates ona contiguous sequence with a specified left and right index. This is called the Search Space. Binary Search maintains the left, right and middle indicies of the search space and compares the search target or applies the search condition to the middle value of the collection; if the condition is unsatisfied or values unequal, the half in which the target cannnot lie is eliminated and the search continues on the remaining half until it is successful. if the search ends with an empty half, the condition cannot be fulfilled and target is not found.</p>
<h3 id="binary-search-template-i">Binary Search Template I</h3>
<pre><code>int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left &lt;= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] &lt; target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left &gt; right
  return -1;
}
</code></pre>
<h3 id="binary-search-template-ii">Binary Search Template II</h3>
<pre><code>int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length;
  while(left &lt; right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] &lt; target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.length &amp;&amp; nums[left] == target) return left;
  return -1;
}
</code></pre>
<h3 id="binary-search-template-iii">Binary Search Template III</h3>
<pre><code>int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 &lt; right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] &lt; target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
</code></pre>
<h3 id="binary-search-template-analysis">Binary Search Template Analysis</h3>
<p>These 3 templates differ by their:</p>
<ul>
<li>left, mid, right index assignments</li>
<li>loop or recursive termination condition</li>
<li>necessity of post-processing</li>
</ul>
<h4 id="template-1-left-right">Template #1 <strong>(left &lt;= right)</strong></h4>
<ul>
<li>Most basic and elmentary form of Binary search</li>
<li>Search Condition can be determined without comparing to the element's neighbors (or use specific elements around it)</li>
<li>No post-precessing required becasuse at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found</li>
</ul>
<h4 id="template-2-left-right">Template #2 <strong>(left &lt; right)</strong></h4>
<ul>
<li>An advanced way to implement Binary Search.</li>
<li>Search Condition needs to access element's immediate right neighbor</li>
<li>Use element's right neighbor to determine if condition is met and decide whether to go left or right</li>
<li>Gurantees Search Space is at least 2 in size at each step</li>
<li>Post-processing required. Loop/Recursion ends when you hava 1 element left. Need to assess if the remaining element meets the condition.</li>
</ul>
<h4 id="template-3-left-1-right">Template #3 <strong>(left + 1 &lt; right)</strong></h4>
<ul>
<li>An alternative way to implement Binary Search</li>
<li>Search Condition needs to access element's immediate left and right neighbors</li>
<li>Use element's neighbors to determine if condition is met and decide whether to go left or right</li>
<li>Gurantees Search Space is at least 3 in size at each step</li>
<li>Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSSåˆçº§å­¦ä¹ ]]></title>
        <id>https://hakuless.github.io/post/css-chu-ji-xue-xi</id>
        <link href="https://hakuless.github.io/post/css-chu-ji-xue-xi">
        </link>
        <updated>2019-05-16T02:24:37.000Z</updated>
        <summary type="html"><![CDATA[<p>å­¦ä¹ ä¸€ä¸‹CSSï¼Œå‰ç«¯è¦æ˜¯è¿è®¾è®¡ç¨¿éƒ½æ— æ³•å®ç°ï¼ŒåŸºæœ¬éœ€æ±‚éƒ½æ»¡è¶³ä¸äº†~</p>
]]></summary>
        <content type="html"><![CDATA[<p>å­¦ä¹ ä¸€ä¸‹CSSï¼Œå‰ç«¯è¦æ˜¯è¿è®¾è®¡ç¨¿éƒ½æ— æ³•å®ç°ï¼ŒåŸºæœ¬éœ€æ±‚éƒ½æ»¡è¶³ä¸äº†~</p>
<!-- more -->
<h2 id="cssè¯­æ³•">CSSè¯­æ³•</h2>
<h3 id="åŸºæœ¬è§„åˆ™">åŸºæœ¬è§„åˆ™</h3>
<p>CSSä¸»è¦ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šé€‰æ‹©å™¨(selector) &amp; å£°æ˜(declarations)</p>
<pre><code>/* selector {property: value} */
h1 {color:red; font-size:14px;}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hakuless.github.io//post-images/1557976004501.png" alt="" loading="lazy"></figure>
<h3 id="æ ·å¼è¡¨ä¹¦å†™">æ ·å¼è¡¨ä¹¦å†™</h3>
<p>ç›®å‰ï¼Œä¸»è¦é‡‡ç”¨å†…è”æ ·å¼è¡¨çš„ä¹¦å†™æ–¹æ¡ˆ</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  	&lt;h1 style=&quot;color:red; font-size:14px;&quot;&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="è§„åˆ™">@è§„åˆ™</h3>
<p>é€šè¿‡@å¼€å¤´ï¼Œåæ¥æ ‡è¯†ç¬¦<br>
ç›®å‰ç”¨çš„æ¯”è¾ƒå¤šçš„æ˜¯ @keyframesï¼Œé€šè¿‡å®šä¹‰å…³é”®å¸§å®ç°åŠ¨ç”»æ•ˆæœ</p>
<pre><code>/* @keyframes */
@keyframes slidein {
    from {
        margin-left: 100%;
        width: 300%;
    }

    to {
        margin-left: 0%;
        width: 100%;
    }
}
</code></pre>
<h2 id="csså·¥ä½œæµç¨‹">CSSå·¥ä½œæµç¨‹</h2>
<h3 id="é¡µé¢æ¸²æŸ“æœºåˆ¶">é¡µé¢æ¸²æŸ“æœºåˆ¶</h3>
<p>é¡µé¢æ¸²æŸ“ä¸»è¦ä»¥ä¸‹5ä¸ªæ­¥éª¤ï¼š</p>
<ol>
<li>å¤„ç†HTMLæ¥åˆ›å»ºDOM treeï¼›</li>
<li>å¤„ç†CSSæ¥åˆ›å»ºCSSOM treeï¼›</li>
<li>æ ¹æ®DOMè·ŸCSSOMæ¥åˆå¹¶render treeï¼›</li>
<li>æ ¹æ®render treeæ¥å¸ƒå±€ï¼›</li>
<li>ç»˜åˆ¶render treeã€‚</li>
</ol>
<h3 id="cssçš„å·¥ä½œæµç¨‹">CSSçš„å·¥ä½œæµç¨‹</h3>
<p><img src="https://hakuless.github.io//post-images/1557976033477.png" alt="" loading="lazy"><br>
<strong>é‡æ’</strong> ä¸ <strong>é‡ç»˜</strong></p>
<h2 id="cssé€»è¾‘å±æ€§">CSSé€»è¾‘å±æ€§</h2>
<h3 id="æ–°æ—§é€»è¾‘å±æ€§å¯¹æ¯”">æ–°æ—§é€»è¾‘å±æ€§å¯¹æ¯”</h3>
<p><img src="https://hakuless.github.io//post-images/1557976478759.png" alt="" loading="lazy"><br>
æ–°æ—§é€»è¾‘å¯¹æ¯”å›¾è¡¨å¦‚ä¸‹ï¼š</p>
<table>
<thead>
<tr>
<th>æ—§çš„é€»è¾‘å±æ€§</th>
<th>æ–°çš„é€»è¾‘å±æ€§</th>
</tr>
</thead>
<tbody>
<tr>
<td>margin-top</td>
<td>margin-block-start</td>
</tr>
<tr>
<td>margin-right</td>
<td>margin-inline-end</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>margin-block-end</td>
</tr>
<tr>
<td>margin-left</td>
<td>margin-inline-start</td>
</tr>
<tr>
<td>border-top</td>
<td>border-block-start</td>
</tr>
<tr>
<td>border-right</td>
<td>border-inline-end</td>
</tr>
<tr>
<td>border-bottom</td>
<td>border-block-end</td>
</tr>
<tr>
<td>border-left</td>
<td>border-inline-start</td>
</tr>
<tr>
<td>padding-top</td>
<td>padding-block-start</td>
</tr>
<tr>
<td>padding-right</td>
<td>padding-inline-end</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>padding-block-end</td>
</tr>
<tr>
<td>padding-left</td>
<td>padding-inline-start</td>
</tr>
<tr>
<td>width</td>
<td>inline-size</td>
</tr>
<tr>
<td>height</td>
<td>block-size</td>
</tr>
</tbody>
</table>
<p>Yè½´æ–¹å‘å±æ€§ä½¿ç”¨ <strong>block</strong>ï¼ŒXè½´æ–¹å‘å±æ€§ä½¿ç”¨ <strong>inline</strong></p>
<h3 id="csså®šä½">CSSå®šä½</h3>
<table>
<thead>
<tr>
<th>æ—§çš„é€»è¾‘å±æ€§</th>
<th>æ–°çš„é€»è¾‘å±æ€§</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>inset-block-start</td>
</tr>
<tr>
<td>bottom</td>
<td>inset-block-end</td>
</tr>
<tr>
<td>left</td>
<td>inset-inline-start</td>
</tr>
<tr>
<td>right</td>
<td>inset-inline-end</td>
</tr>
</tbody>
</table>
<pre><code>/* æ—§çš„é€»è¾‘å±æ€§ */
.popup{
  position:fixed;  
  top:0;
  bottom:0;
  left:0;
  right:0;
}
/* æ–°çš„é€»è¾‘å±æ€§ */
.popup{
   position:fixed;
   inset-block-start:0;  /*top - in English*/
   inset-block-end:0;    /*bottom - in English*/
   inset-inline-start:0; /*left - in English*/
   inset-inline-end:0;   /*right - in English*/
}
/* æ–°çš„é€»è¾‘å±æ€§æ”¯æŒç®€å†™ */
.popup{
   position:fixed;
   inset:0 0 0 0;   /*top, right, bottom, left - in English*/
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1557977057594.png" alt="" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1557977069217.png" alt="" loading="lazy"></p>
<h2 id="cssç›’å­æ¨¡å‹">CSSç›’å­æ¨¡å‹</h2>
<p>å¾…è¡¥å……</p>
<h2 id="cssé€‰æ‹©å™¨">CSSé€‰æ‹©å™¨</h2>
<h3 id="åŸºæœ¬é€‰æ‹©å™¨">åŸºæœ¬é€‰æ‹©å™¨</h3>
<ol>
<li>ç±»å‹é€‰æ‹©å™¨ï¼š ç›´æ¥htmlæ ‡ç­¾ï¼Œå¦‚ html {width: 100%;}</li>
<li>ç±»é€‰æ‹©å™¨ï¼šhtmlæ ‡ç­¾ä¸­classå±æ€§çš„å€¼ï¼Œå¦‚ .div {width: 100%;}</li>
<li>IDé€‰æ‹©å™¨ï¼šç°åœ¨ä¸å’‹ç”¨äº†ï¼Œé€šè¿‡htmlæ ‡ç­¾çš„IDå±æ€§æ¥é€‰æ‹©</li>
<li>é€šç”¨é€‰æ‹©å™¨ï¼šæ›´ä¸ä¼šç”¨... æ‰€æœ‰æ ‡ç­¾ç”Ÿæ•ˆ...</li>
<li>å±æ€§é€‰æ‹©å™¨ï¼šæ ¹æ®htmlæ ‡ç­¾é‡Œçš„å±æ€§é€‰æ‹©ï¼Ÿï¼Ÿï¼Ÿ</li>
</ol>
<h3 id="ç»„åˆé€‰æ‹©å™¨">ç»„åˆé€‰æ‹©å™¨</h3>
<ol>
<li>ç©ºæ ¼ï¼šåä»£é€‰æ‹©å™¨ï¼Œ<strong>.a .b</strong> æ‰€æœ‰åä»£éƒ½ç”Ÿæ•ˆ</li>
<li>
<blockquote>
<p>ï¼šå­ä»£é€‰æ‹©å™¨ï¼Œ<strong>.a &gt; .b</strong> åªåœ¨ä¸€çº§å„¿å­ç”Ÿæ•ˆ</p>
</blockquote>
</li>
<li>~ï¼šåç»§é€‰æ‹©å™¨ï¼Œ<strong>.a ~ .b</strong> å¼Ÿå¼Ÿé€‰æ‹©å™¨ï¼Œå“¥å“¥ä¸ç”Ÿæ•ˆ</li>
<li>+ï¼šç›´æ¥åç»§é€‰æ‹©å™¨ï¼Œ<strong>.a + .b</strong> èƒ½ç”Ÿæ•ˆçš„ç¬¬ä¸€ä¸ªå¼Ÿå¼Ÿç”Ÿæ•ˆ</li>
<li>|ï¼šå‘½åç©ºé—´é€‰æ‹©å™¨ï¼Œ<strong>.a | .b</strong> ä¸åä»£ç±»ä¼¼</li>
<li>||ï¼šåˆ—è¡¨é€‰æ‹©å™¨ï¼Œç›´æ¥æ— è§†ï¼Œè¿™è¾ˆå­éƒ½ä¸ä¼šç”¨çš„</li>
</ol>
<h3 id="ä¼ªç±»-ä¸-ä¼ªå…ƒç´ ">ä¼ªç±» ä¸ ä¼ªå…ƒç´ </h3>
<p><strong>ä¼ªç±»</strong>ï¼šä¼ªç±»æ˜¯æ·»åŠ åˆ°é€‰æ‹©å™¨çš„å…³é”®å­—ï¼ŒæŒ‡å®šè¦é€‰æ‹©çš„å…ƒç´ çš„ç‰¹æ®ŠçŠ¶æ€ï¼Œå¦‚ a:hoverï¼Œé¼ æ ‡æ‚¬åœçŠ¶æ€çš„æ•ˆæœ</p>
<pre><code>// è¯­æ³•
selector:pseudo-class {
  property: value;
}
</code></pre>
<p><strong>ä¼ªå…ƒç´ </strong>ï¼šä¼ªå…ƒç´ æ˜¯ä¸€ä¸ªé™„åŠ è‡³é€‰æ‹©å™¨æœ«çš„å…³é”®è¯ï¼Œå…è®¸ä½ å¯¹è¢«é€‰æ‹©å…ƒç´ çš„ç‰¹å®šéƒ¨åˆ†ä¿®æ”¹æ ·å¼ã€‚ä¸€ä¸ªé€‰æ‹©å™¨ä¸­åªèƒ½ä½¿ç”¨ä¸€ä¸ªä¼ªå…ƒç´ ï¼Œå¦‚ a::after { content: &quot;â†’&quot;; } åœ¨æ‰€æœ‰aç±»å‹åå¢åŠ ä¸€ä¸ªç®­å¤´å…ƒç´ </p>
<pre><code>// è¯­æ³•
selector::pseudo-element {
  property: value;
}
</code></pre>
<h3 id="csså‡½æ•°">CSSå‡½æ•°</h3>
<ul>
<li>å±æ€§å‡½æ•°ï¼šattr()ï¼›</li>
<li>èƒŒæ™¯å›¾ç‰‡å‡½æ•°ï¼šlinear-gradient()ã€radial-gradient()ã€conic-gradient()ã€repeating-linear-gradient()ã€repeating-radial-gradient()ã€repeating-conic-gradient()ã€image-set()ã€image()ã€url()ã€element()ï¼›</li>
<li>é¢œè‰²å‡½æ•°ï¼šrgb()ã€rgba()ã€hsl()ã€hsla()ã€hwb()ã€color-mod()ï¼›</li>
<li>å›¾å½¢å‡½æ•°ï¼šcircle()ã€ellipse()ã€inset()ã€polygon()ã€path()</li>
<li>æ»¤é•œå‡½æ•°ï¼šblur()ã€brightness()ã€contrast()ã€drop-shadow()ã€grayscale()ã€hue-rotate()ã€invert()ã€opacity()ã€saturate()ã€sepia()ï¼›</li>
<li>è½¬æ¢å‡½æ•°ï¼šmatrix()ã€matrix3d()ã€perspective()ã€rotate()ã€rotate3d()ã€rotateX()ã€rotateY()ã€rotateZ()ã€scale()ã€scale3d()ã€scaleX()ã€scaleY()ã€scaleZ()ã€skew()ã€skewX()ã€skewY()ã€translate()ã€translateX()ã€translateY()ã€translateZ()ã€translate3d()ï¼›</li>
<li>æ•°å­¦å‡½æ•°ï¼šcalc()ã€min()ã€max()ã€mixmax()ã€repeat()ï¼›</li>
<li>ç¼“åŠ¨å‡½æ•°ï¼šcubic-bezier()ã€steps()ï¼›</li>
<li>å…¶ä»–å‡½æ•°ï¼šcounter()ã€counters()ã€toggle()ã€var()ã€ symbols()ã€‚<br>
<a href="https://www.w3cplus.com/css/css-functions.html">CSSå‡½æ•°è¯´æ˜</a></li>
</ul>
<h2 id="å‚è€ƒèµ„æ–™">å‚è€ƒèµ„æ–™</h2>
<p><a href="https://krissarea.gitee.io/blog/">é±¼å¤´çš„æµ·ä¸Šä¸–ç•Œ</a><br>
<a href="https://www.w3.org/TR/?tag=css">CSS W3Cæ ‡å‡†æ–‡æ¡£</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS MDNæ–‡æ¡£</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSè¯­æ³•å­¦ä¹ ]]></title>
        <id>https://hakuless.github.io/post/js-yu-fa-xue-xi</id>
        <link href="https://hakuless.github.io/post/js-yu-fa-xue-xi">
        </link>
        <updated>2019-05-09T03:41:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="generators">Generators</h2>
<h2 id="promise">Promise</h2>
<h2 id="asyncawait">Async/Await</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stack & DFS]]></title>
        <id>https://hakuless.github.io/post/stack-and-dfs</id>
        <link href="https://hakuless.github.io/post/stack-and-dfs">
        </link>
        <updated>2019-02-19T12:00:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="stack-dfs">Stack &amp; DFS</h3>
<p>Similar to BFS, <strong>Depth-First Search</strong> can also be used to find the path from the root node to the target node.</p>
<p>The first path you found in DFS is not always the shortest path.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="stack-dfs">Stack &amp; DFS</h3>
<p>Similar to BFS, <strong>Depth-First Search</strong> can also be used to find the path from the root node to the target node.</p>
<p>The first path you found in DFS is not always the shortest path.</p>
<!-- more -->
<h3 id="dfs-template-i">DFS - Template I</h3>
<h4 id="template-recursion">Template - Recursion</h4>
<pre><code>/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
</code></pre>
<h3 id="dfs-template-ii">DFS - Template II</h3>
<p>The advantage of the recursion solution is that it is easier to implement. However, there is a huge disadvantage: if the depth of recursion is too high, youwill suffer from <strong>stack overflow</strong>.  In that case, you might want to use BFS instead or implement DFS using an explicit stack.</p>
<pre><code>/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set&lt;Node&gt; visited;
    Stack&lt;Node&gt; stack;
    add root to stack;
    while (s is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
</code></pre>
]]></content>
    </entry>
</feed>