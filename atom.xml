<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hakuless.github.io/</id>
    <title>HaKuLess</title>
    <updated>2020-02-19T08:59:06.909Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hakuless.github.io/"/>
    <link rel="self" href="https://hakuless.github.io/atom.xml"/>
    <subtitle>精神病人思路广，脑残儿童欢乐多</subtitle>
    <logo>https://hakuless.github.io/images/avatar.png</logo>
    <icon>https://hakuless.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, HaKuLess</rights>
    <entry>
        <title type="html"><![CDATA[1340. Jump Game V —— 题解]]></title>
        <id>https://hakuless.github.io/post/1340-jump-game-v-ti-jie</id>
        <link href="https://hakuless.github.io/post/1340-jump-game-v-ti-jie">
        </link>
        <updated>2020-02-19T08:43:50.000Z</updated>
        <summary type="html"><![CDATA[<p>Contest 174的Q4，如上文所述，由于在Contest中耗费大量精力去搞Q3的 DFS to BFS结果导致两道题都没搞定... （还是太年轻~）<br>
Jump Game系列也来到了第五代，这一系列的题目都很经典，覆盖了贪心、BFS、DFS、DP等许多算法，下面让我们一起来看看这个第五代吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>Contest 174的Q4，如上文所述，由于在Contest中耗费大量精力去搞Q3的 DFS to BFS结果导致两道题都没搞定... （还是太年轻~）<br>
Jump Game系列也来到了第五代，这一系列的题目都很经典，覆盖了贪心、BFS、DFS、DP等许多算法，下面让我们一起来看看这个第五代吧</p>
<!-- more -->
<h3 id="题目描述">题目描述</h3>
<p>给定一个整型数组arr和一个整数d，整型数组上的点代表这个点所在的高度，整数d代表人能够移动的最大横向距离。人可以从整型中的任意一个Index出发，到另一个index上，需要满足条件：</p>
<ol>
<li>只能在数组范围内移动，即我们的index只能在整型数组的indices中</li>
<li>单步移动的最大距离只能是d，即从当前移动的范围是[cur-d, cur+d]</li>
<li>移动目标 及 与当前目标的中间值 都要小于当前值（人只能向下跳，不能向上爬）<br>
求问，人最多能够移动几次？<br>
<img src="https://hakuless.github.io//post-images/1582102355985.jpeg" alt="" loading="lazy"><br>
如上图所述，以下为index值<br>
在d = 2时，10 -&gt; 8 -&gt; 6 -&gt; 7 因此结果是4<br>
在d = 3时，2 -&gt; 5 -&gt; 8 -&gt; 6 -&gt; 7 因此结果是5</li>
</ol>
<h3 id="题目分析">题目分析</h3>
<ol>
<li>某一Index的最优解是一定的，不因其他状态而改变</li>
<li>同时，当前状态的最优解，可以依赖于附近最多2*d个状态求解<br>
通过上述条件，可以发现一个精简的解法：DFS + Memo</li>
</ol>
<h3 id="解法一dfs-memo">解法一：DFS + Memo</h3>
<pre><code class="language-Kotlin">fun maxJumps(arr: IntArray, d: Int): Int {
    // 初始化DP数组，值代表在index位置上的最优解，-1为未求解状态
    val dp = IntArray(arr.size) { -1 }
    for (i in 0..arr.lastIndex) {
        helper(arr, dp, i, d)
    }
    return dp.max()!!
}

private fun helper(arr: IntArray, dp: IntArray, cur: Int, d: Int): Int {
    // 若已经有值，则直接返回结果，优化子问题
    if (dp[cur] != -1) {
        return dp[cur]
    }
    // 默认自己为1，仅能站在自己的位置上
    dp[cur] = 1
    // 向前跳
    for (i in cur - 1 downTo cur - d) {
        if (i !in dp.indices)
            break
        // 若中间遇到更高的则停止，无法跳跃
        if (arr[i] &gt;= arr[cur]) {
            break
        }
        // 查找子问题
        dp[cur] = maxOf(dp[cur], helper(arr, dp, i, d) + 1)
    }
    // 同理向后跳
    for (i in cur + 1..cur + d) {
        if (i !in dp.indices)
            break
        if (arr[i] &gt;= arr[cur]) {
            break
        }
        dp[cur] = maxOf(dp[cur], helper(arr, dp, i, d) + 1)
    }
    return dp[cur]
}
</code></pre>
<h3 id="解法二sort-dp">解法二：Sort + DP</h3>
<p>DP的动态方程大家比较好想，那就是dp[i] = maxOf(dp[i - d..i + d] + 1)，其中 (i - d) ~ (i + d)需要符合不跨越等高or更高的value，同时要求这些dp值已经是求好的值。<br>
那么，我们只需要从低到高排序后再去计算就能保障需要用到的值，肯定是已经算好了的，具体代码如下：</p>
<pre><code class="language-Kotlin">fun maxJumps(arr: IntArray, d: Int): Int {
    val sort = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;()
    arr.forEachIndexed { index, i -&gt;
        sort.add(Pair(index, i))
    }
    sort.sortBy { it.second }
    val dp = IntArray(arr.size) { -1 }
    sort.forEach {
        var max = 1
        for (i in it.first + 1..it.first + d) {
            if (i !in arr.indices || arr[i] &gt;= it.second) {
                break
            }
            // 由于事先排序，这里的dp[i]可以保证都是有效的正数值
            max = maxOf(max, 1 + dp[i])
        }
        for (i in it.first - 1 downTo it.first - d) {
            if (i !in arr.indices || arr[i] &gt;= it.second) {
                break
            }
            max = maxOf(max, 1 + dp[i])
        }
        dp[it.first] = max
    }
    return dp.max()!!
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1339. Maximum Product of Splitted Binary Tree —— 题解]]></title>
        <id>https://hakuless.github.io/post/1339-maximum-product-of-splitted-binary-tree-ti-jie</id>
        <link href="https://hakuless.github.io/post/1339-maximum-product-of-splitted-binary-tree-ti-jie">
        </link>
        <updated>2020-02-10T07:43:50.000Z</updated>
        <summary type="html"><![CDATA[<p>Contest 174的Q3，问题很简洁，把一棵树分成两部分，使两部分的和的乘积最小，求这个最大值（mod 10^9 + 7），不过这题对Kotlin很不友好，下面会详述</p>
]]></summary>
        <content type="html"><![CDATA[<p>Contest 174的Q3，问题很简洁，把一棵树分成两部分，使两部分的和的乘积最小，求这个最大值（mod 10^9 + 7），不过这题对Kotlin很不友好，下面会详述</p>
<!-- more -->
<h3 id="分析题目">分析题目</h3>
<figure data-type="image" tabindex="1"><img src="https://hakuless.github.io//post-images/1581320864937.png" alt="" loading="lazy"></figure>
<ol>
<li>首先整棵树的和是一定的，拆分两部分，一部分是x，那么另一部分就是 sum - x，它们的乘积就是 x * (sum - x)</li>
<li>拆分两部分后，一部分是以原来的根结点为根，而另一部分则可能是以原来任一点为根节点</li>
</ol>
<h3 id="解法一dfs">解法一：DFS</h3>
<p>通过上述描述，我们可以想到解法，通过DFS遍历算出每个点包含的子节点的总和，算出如果以自己为新树的根，所求的结果是多少，然后求出它们中的最大值即可</p>
<pre><code class="language-Kotlin">var max = 0L
val mod = 1000000007

fun maxProduct(root: TreeNode?): Int {
    val sum = dfs(root)
    helper(root, sum)
    return (max % mod).toInt()
}

private fun dfs(root: TreeNode?): Int {
    if (root == null) {
        return 0
    }
    return root.`val` + dfs(root.left) + dfs(root.right)
}

private fun helper(root: TreeNode?, sum: Int): Long {
    if (root == null) {
        return 0
    }
    val left = helper(root.left, sum)
    val right = helper(root.right, sum)
    max = maxOf(max, left * (sum - left))
    max = maxOf(max, right * (sum - right))
    return root.`val` + left + right
}
</code></pre>
<h4 id="遇到的坑">遇到的坑</h4>
<p>当我们把上述代码粘到LeetCode里并提交后，会发现某个Case报了StackOverflow... 看样子栈不够深，但是当Contest结束后，看了下其他人的提交（用Java or Python）使用的方法都是类似的... 这就悲剧了...</p>
<p>于是，让我们测试下LeetCode上的Java栈与Kotlin栈深度做个比较</p>
<ol>
<li>首先上Java代码</li>
</ol>
<pre><code class="language-Java">public int maxProduct(TreeNode root) {
    dfs(0);
    return 0;
}

public void dfs(int a) {
    System.out.println(a);
    dfs(a + 1);
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1581322913478.png" alt="" loading="lazy"><br>
2. 再让我们看看Kotlin代码</p>
<pre><code class="language-Kotlin">fun maxProduct(root: TreeNode?): Int {
    test(0)
    return 0
}

fun test(l: Int) {
    println(l)
    test(l + 1)
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1581321912617.png" alt="" loading="lazy"><br>
结果如上图，可以看出Kotlin的方法栈深度约为9000，那当树的深度超过9000基本就GG了... 而Java的报错竟然都不是StackOverFlow而是TLE，基本上Java栈就是无限...</p>
<h3 id="解法二bfs">解法二：BFS</h3>
<p>活人不能让尿憋死，既然Kotlin的DFS不行，那我们就改成BFS，从下到上一层一层的遍历，同时记录每个Item的Parent，遍历相加，代码如下：</p>
<pre><code class="language-Kotlin">var max = 0L
val mod = 1000000007
val map = HashMap&lt;TreeNode, Int&gt;()
private val parent = HashMap&lt;TreeNode, TreeNode&gt;()

fun maxProduct(root: TreeNode?): Int {
    var sum = 0
    val queue: Queue&lt;TreeNode?&gt; = LinkedList()
    queue.add(root)
    val all = ArrayList&lt;TreeNode&gt;()
    while (queue.isNotEmpty()) {
        val size = queue.size
        for (i in 0 until size) {
            val item = queue.poll()
            if (item != null) {
                all.add(item)
                if (item.left != null) {
                    parent[item.left!!] = item
                    queue.offer(item.left)
                }
                if (item.right != null) {
                    parent[item.right!!] = item
                    queue.offer(item.right)
                }
                sum += item.`val`
            }
        }
    }

    all.forEach {
        map[it] = it.`val`
    }

    all.reversed().forEach {
        val item = it
        if (parent.containsKey(item)) {
            map[parent[item]!!] = map[parent[item]!!]!! + map[item]!!
        }
    }

    map.forEach {
        max = maxOf(max, it.value.toLong() * (sum - it.value))
    }
    return (max % mod).toInt()
}
</code></pre>
<p>这个明显要比DFS复杂些，Contest的时候搞了半天，结果Q4都没来得及做... 悲剧啊... 跟LeetCode官方发个邮件看能不能处理下Kotlin的这个问题...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1326. Minimum Number of Taps to Open to Water a Garden —— 题解]]></title>
        <id>https://hakuless.github.io/post/1326-minimum-number-of-taps-to-open-to-water-a-garden-ti-jie</id>
        <link href="https://hakuless.github.io/post/1326-minimum-number-of-taps-to-open-to-water-a-garden-ti-jie">
        </link>
        <updated>2020-02-03T06:17:18.000Z</updated>
        <summary type="html"><![CDATA[<p>Contest 172 Q4，作为压轴题题目不算太难，做的时候搞错了点与线段，然后在错误的道路上越走越远...<br>
附原题链接<a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/">Minimum Number of Taps to Open to Water a Garden</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Contest 172 Q4，作为压轴题题目不算太难，做的时候搞错了点与线段，然后在错误的道路上越走越远...<br>
附原题链接<a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/">Minimum Number of Taps to Open to Water a Garden</a></p>
<!-- more -->
<h3 id="题目描述">题目描述</h3>
<p>一个一维的线段组成的花园，线段上每个点都有一个水龙头，给出每个水龙头能浇的范围，问最少能用几个水龙头覆盖整个花园。如下图所示：<br>
<img src="https://hakuless.github.io//post-images/1580714329749.png" alt="" loading="lazy"><br>
花园范围是[0..5]，给出浇盖范围是[3,4,1,1,0,0]<br>
水龙头0能覆盖[0..3]<br>
水龙头1能覆盖[0..5]<br>
水龙头2能覆盖[1..3]<br>
水龙头3能覆盖[3..4]</p>
<ul>
<li>负数及大于5的数不用考虑</li>
<li>范围是0则只是一个点，可以直接不看</li>
</ul>
<h3 id="题目解析">题目解析</h3>
<ol>
<li>覆盖的是范围，因此如果某个水龙头范围是0，则无效（至少要1）</li>
<li>结果只要求水龙头的数量，对使用哪些不关心，直觉上使用暴力贪心</li>
<li>数据范围是 1 &lt;= n &lt;= 10^4，复杂度使用O(n²)估计也可以过</li>
</ol>
<h3 id="解法一-暴力贪心">解法一 暴力贪心</h3>
<ol>
<li>设置p为 当前必须要被浇到的点（即p之前已经被浇到了，从0开始）</li>
<li>q为覆盖到当前浇到的点的水龙头能到达的最远距离</li>
<li>每次循环完成，将q赋值给p（注意，这里是需要连续的，即浇【4, 6】后必须要【6, n】而不是【7, n】，因为【6, 7】之间的土地部分，我们浇的不是点而是连续的线段）</li>
<li>如果p走到了 &gt;= n，代表当前选择的数量已足够覆盖到整个花园，直接return即可</li>
<li>如果某次循环p == q，代表当前已经没有进步空间了...下一段没有任何水龙头能浇到，因此直接return -1</li>
<li>时间复杂度为 O(n²)，比较暴力的解法，第二层for循环是从0到n的</li>
</ol>
<pre><code class="language-Kotlin">fun minTaps(n: Int, ranges: IntArray): Int {
    var p = 0
    var q = 0
    var res = 0
    while (p &lt; n) {
        for (i in 0..n) {
            if (i - ranges[i] &lt;= p) {
                q = maxOf(q, i + ranges[i])
            }
        }
        if (p == q) return -1
        p = q
        res++
    }
    return res
}
</code></pre>
<h3 id="解法二-优化贪心">解法二 优化贪心</h3>
<ol>
<li>上面的解法是双层for循环完整遍历，如果对原始数据进行排序，可以只遍历一次</li>
<li>首先将每个点能覆盖到的范围计算出intervals列表</li>
<li>按照左侧进行排序，遍历的时候只需要一遍即可</li>
<li>内部原理与上述相同，cur代表当前必须被浇灌到的点，next为当前覆盖cur的同时能够覆盖最远的点</li>
<li>时间复杂度 为 O(nlogn)</li>
</ol>
<pre><code class="language-Kotlin">fun minTaps(n: Int, ranges: IntArray): Int {
    val intervals = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;()
    for (i in 0..n) {
        intervals.add(Pair(i - ranges[i], i + ranges[i]))
    }
    intervals.sortBy { it.first }
    var ans = 0
    var cur = 0
    var next = 0
    var index = 0
    while (index &lt;= n) {
        val it = intervals[index]
        if (it.first &lt;= cur) {
            next = maxOf(next, it.second)
            index++
            if (next &gt;= n) {
                return ans + 1
            }
        } else {
            if (next == cur) {
                return -1
            }
            cur = next
            ans++
        }
    }
    return ans
}
</code></pre>
<h3 id="解法三-再优化贪心">解法三 再优化贪心</h3>
<p>上述解法因排序而使事件复杂度变成O(nlogn)，那么如果能够不适用排序则可以再次降低时间复杂度到O(n)</p>
<ol>
<li>我们来设置一个长度为n+1的数组bounds，bounds[i]代表以i为起点能覆盖到的最远点</li>
<li>设置初始条件，0必须覆盖
<ol>
<li>ans从1开始（即覆盖0）</li>
<li>当前ans所能覆盖到的最大值cur</li>
<li>遍历到目前为止可能覆盖到的最大值next</li>
</ol>
</li>
<li>然后遍历1..n
<ol>
<li>如果index已经超出可能覆盖的最大值，那么[index-1..index]中的部分是无法被覆盖到的，直接-1</li>
<li>当index&gt;cur &amp;&amp; index &lt;=next时，需要新开一个水龙头才能覆盖index，并且更新当前最大距离</li>
<li>不断更新遍历到当前能覆盖到的最大值</li>
</ol>
</li>
<li>可以看出，整个算法事件复杂度为O(n)，巧妙的利用数组存储以每个点为起点能覆盖到的最大值 &amp;&amp; 遍历时不断更新next值，而避免了排序的过程</li>
</ol>
<pre><code class="language-Kotlin">fun minTaps(n: Int, ranges: IntArray): Int {
    val bounds = IntArray(n + 1)
    ranges.forEachIndexed { index, it -&gt;
        val left = maxOf(0, index - it)
        val right = minOf(n, index + it)
        bounds[left] = right
    }
    var ans = 1
    var cur = bounds[0]
    var next = bounds[0]

    for (i in 1..n) {
        if (i &gt; next) return -1
        if (i &gt; cur) {
            ans++
            cur = next
        }
        if (bounds[i] &gt; next) {
            next = bounds[i]
        }
    }
    return ans
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1114. Print in Order —— 题解]]></title>
        <id>https://hakuless.github.io/post/1114-print-in-order-ti-jie</id>
        <link href="https://hakuless.github.io/post/1114-print-in-order-ti-jie">
        </link>
        <updated>2020-02-03T03:32:34.000Z</updated>
        <summary type="html"><![CDATA[<p>最近工作中终于有些多线程的Case了，玩一玩LeetCode多线程的题目，复习一下知识（N久没有开发过多线程交互的代码了...）<br>
附上题目链接 <a href="https://leetcode.com/problems/print-in-order/">Print in Order</a>😁</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近工作中终于有些多线程的Case了，玩一玩LeetCode多线程的题目，复习一下知识（N久没有开发过多线程交互的代码了...）<br>
附上题目链接 <a href="https://leetcode.com/problems/print-in-order/">Print in Order</a>😁</p>
<!-- more -->
<h3 id="原题描述">原题描述</h3>
<p>给定一个如下的类Foo，ABC三个线程分别调用 first、second、third方法，但是无论ABC的调用顺序如何，我们的输出顺序保持着1、2、3</p>
<pre><code class="language-Kotlin">public class Foo {
  public void first() { print(&quot;first&quot;); }
  public void second() { print(&quot;second&quot;); }
  public void third() { print(&quot;third&quot;); }
}
</code></pre>
<h3 id="变种">变种</h3>
<p>由于LeetCode上的多线程题目不支持Kotlin代码，因此自己设置主函数 并 稍微改变下题目，方便观察结果<br>
首先，我们把主函数设置为如下代码：</p>
<pre><code class="language-Kotlin">fun main(args: Array&lt;String&gt;) {
    val max = 1000
    val s = Foo()
    thread {
        for (i in 0..max)
            s.first()
    }
    thread {
        for (i in 0..max)
            s.second()
    }
    thread {
        for (i in 0..max)
            s.third()
    }
}
</code></pre>
<ol>
<li>共有三个不同线程，每个线程自己会去执行Foo的first、second、third方法各1001次</li>
<li>我们希望打印first先执行，然后执行second，再执行third(循环反复)</li>
<li>最终每个打印都1001次，共计3003次</li>
</ol>
<h3 id="解法一countdownlatch">解法一：CountDownLatch</h3>
<ol>
<li>分别设置三个不同的CountDownLatch，分别拦截first、second、third</li>
<li>最开始first不用拦截，默认设置c0为0</li>
<li>执行自己时，将下一道门countDown掉（每个执行都到等待自己的门）</li>
<li>执行完成自己，重新把自己的门闩设置上（防止重复执行某一个）</li>
</ol>
<pre><code class="language-Kotlin">class Foo {
    private var c0 = CountDownLatch(0)
    private var c1 = CountDownLatch(1)
    private var c2 = CountDownLatch(1)

    fun first() {
        c0.await()
        println(&quot;first&quot;)
        c0 = CountDownLatch(1)
        c1.countDown()
    }

    fun second() {
        c1.await()
        println(&quot;second&quot;)
        c1 = CountDownLatch(1)
        c2.countDown()
    }

    fun third() {
        c2.await()
        println(&quot;third&quot;)
        c2 = CountDownLatch(1)
        c0.countDown()
    }
}
</code></pre>
<h3 id="解法二-reentrantlock-with-condition">解法二： ReentrantLock with Condition</h3>
<ol>
<li>使用变量cur，代表当前允许执行的方法</li>
<li>首先在first、second、third中都加入lock()和unlock()，保证每次只会有一个方法执行</li>
<li>执行时进行变量判断，根据条件执行打印 or condition.wait()</li>
<li>执行完成后，修改变量cur &amp;&amp; 提示下一个condition可以执行</li>
</ol>
<pre><code class="language-Kotlin">class Foo {

    private val lock = ReentrantLock()

    var cur = 1
    private val c1 = lock.newCondition()
    private val c2 = lock.newCondition()
    private val c3 = lock.newCondition()

    fun first() {
        lock.lock()
        if (cur != 1) {
            c1.await()
        }
        println(&quot;first&quot;)
        cur = 2
        c2.signal()
        lock.unlock()
    }

    fun second() {
        lock.lock()
        if (cur != 2) {
            c2.await()
        }
        println(&quot;second&quot;)
        cur = 3
        c3.signal()
        lock.unlock()
    }

    fun third() {
        lock.lock()
        if (cur != 3) {
            c3.await()
        }
        println(&quot;third&quot;)
        cur = 1
        c1.signal()
        lock.unlock()
    }
}
</code></pre>
<h3 id="解法三-object锁-wait-notify">解法三： Object锁 &amp; wait &amp; notify</h3>
<p>该方法直接利用Object类中的wait方法（由于Kotlin中的Any并没有，因此需要使用as强转一下）停住线程</p>
<ol>
<li>通过 @Synchronized 注解使三个方法互斥</li>
<li>同样设置cur为当前可执行的方法变量</li>
<li>通过while循环判断是否可执行，不可执行则wait，可执行则执行并notifyAll</li>
</ol>
<p>注：</p>
<ol>
<li>这里需要用while判断，而非解法二中的if判断，主要是notifyAll会唤醒其他所有的wait，而wait唤醒后是继续执行，如果使用if则有可能条件仍不匹配，但是执行下去，导致与要求不符</li>
<li>可以看出解法三不如1、2的控制精准，能够唤醒特定线程</li>
</ol>
<pre><code class="language-Kotlin">class Foo {
    var cur = 1

    @Synchronized
    fun first() {
        while (cur != 1) {
            (this as Object).wait()
        }
        println(&quot;first&quot;)
        cur = 2
        (this as Object).notifyAll()
    }

    @Synchronized
    fun second() {
        while (cur != 2) {
            (this as Object).wait()
        }
        println(&quot;second&quot;)
        cur = 3
        (this as Object).notifyAll()
    }

    @Synchronized
    fun third() {
        while (cur != 3) {
            (this as Object).wait()
        }
        println(&quot;third&quot;)
        cur = 1
        (this as Object).notifyAll()
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1105. Filling Bookcase Shelves —— 题解]]></title>
        <id>https://hakuless.github.io/post/1105-filling-bookcase-shelves-ti-jie</id>
        <link href="https://hakuless.github.io/post/1105-filling-bookcase-shelves-ti-jie">
        </link>
        <updated>2019-07-03T07:19:48.000Z</updated>
        <summary type="html"><![CDATA[<p>本周状态不错，可惜好几周没有DP的题，一下卡住了...<br>
<a href="https://leetcode.com/problems/filling-bookcase-shelves/">https://leetcode.com/problems/filling-bookcase-shelves/</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>本周状态不错，可惜好几周没有DP的题，一下卡住了...<br>
<a href="https://leetcode.com/problems/filling-bookcase-shelves/">https://leetcode.com/problems/filling-bookcase-shelves/</a></p>
<!-- more -->
<h3 id="题目大意">题目大意</h3>
<p>给出一组书，书有宽、高，架子也有宽度，按照顺序从上向下摆放，问架子至少需要多高才能把书都放完，如下图所示：<br>
<img src="https://hakuless.github.io//post-images/1562138680833.png" alt="" loading="lazy"><br>
这里需要注意</p>
<ol>
<li>书是按顺序放的，所以4、5、6无法放到1的右侧，不属于贪心</li>
<li>换行策略，如2可以放在1的右侧，但是3就要另起一行，相对占用高度会更大</li>
</ol>
<h3 id="题解">题解</h3>
<p>使用动态规划求解这类 <strong>中间状态</strong> &amp;&amp; <strong>下一个输入</strong> 确定 <strong>下一个状态</strong> 的问题<br>
本题中，如果没有7的输入，那么高度会是5，而成为6原因是前6个输入的结果<br>
第7本书可以独立一行，or 与前边连续的n本书一起一行（n从0到6，总体宽度不可以大于架子宽度）<br>
那么 前6本书的最小高度也可以依照该逻辑求出，即每个状态下的最小高度，最后得出动态方程为</p>
<pre><code>// n从0取到K-1，直到它们总宽度大于架子宽度
dp[k] = minOf[dp[k], dp[k-n] + max[height{k-n..k}]]
</code></pre>
<p>具体题解代码如下：</p>
<pre><code class="language-Kotlin">fun minHeightShelves(books: Array&lt;IntArray&gt;, shelf_width: Int): Int {
		val n = books.size
		val height = IntArray(n + 1)
		for (i in 0 until n) {
				var min = Int.MAX_VALUE
				var h = 0
				var w = 0
				for (j in i downTo 0) {
						h = maxOf(h, books[j][1])
						w += books[j][0]
						if (w &gt; shelf_width) break
						min = minOf(min, h + height[j])
				}
				height[i + 1] = min
		}
		return height[n]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Union-Find Set]]></title>
        <id>https://hakuless.github.io/post/union-find-set</id>
        <link href="https://hakuless.github.io/post/union-find-set">
        </link>
        <updated>2019-05-25T03:51:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>并查集是个很有意思的数据结构，它的主要功能是把不同的元素 分组 并 关联 起来，能够在 O(1) 时间内判断两个元素是否在一组里。关系具有传递性的问题，都可以利用并查集处理。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>并查集是个很有意思的数据结构，它的主要功能是把不同的元素 分组 并 关联 起来，能够在 O(1) 时间内判断两个元素是否在一组里。关系具有传递性的问题，都可以利用并查集处理。</p>
 <!-- more -->
<h2 id="function">function</h2>
<p>并查集的核心主要是两个方法，一个是查找 <strong>find(x)</strong>，通过传入元素，返回元素所在组的Key（不同元素返回的Key值相同，代表这些元素在同一组里）。另一个是 <strong>union(x, y)</strong>，将两个不同的元素合并为一组，同时属于这两组的数据都在一个大组内。</p>
<pre><code>class UnionFindSet:
	func UnionFindSet(n):
		parents = [1..n]
		rank = [0..0] (n zeros)
	
	func Find(x):
		if x != parents[x]:
			parents[x] = Find(parents[x])
		return parents[x]
		
	func Union(x, y):
		px, py = Find(x), Find(y)
		if ranks[px] &gt; ranks[py]: parents[py] = px
		if ranks[px] &lt; ranks[py]: parents[px] = py
		if ranks[px] == ranks[py]
			parents[py] = px
			ranks[px]++
</code></pre>
<p>上面是伪代码，注意到有两个部分：</p>
<ol>
<li>find(x) 通过递归一直向上寻找，并不断的赋值</li>
<li>union(x, y)过程，会根据 ranks值进行比较，然后merge方式不同</li>
</ol>
<h3 id="path-compression">Path Compression</h3>
<p>首先，find寻找过程中同时进行 <strong>path compression</strong> 优化，如建立关联关系时，整个关联图的关系非常的长，如下图：<br>
<img src="https://hakuless.github.io//post-images/1558768567180.png" alt="" loading="lazy"><br>
当我们要查找1所在组时，会一直遍历到链表头，会非常耗时，因此需要在find过程中进行优化，把1、2、3、5（查找的数据及其所有祖先）均直接指向8（Class ID），拉平我们的树结构（flatten the structure），变成如下图所示：<br>
<img src="https://hakuless.github.io//post-images/1558768774411.png" alt="" loading="lazy"><br>
这时候我们再次查找时，会大大减少遍历所需时间</p>
<h3 id="union-by-rank">Union By Rank</h3>
<p>合并的过程，我们通过Union By Rank来进行优化，原理与上述内容类似，就是为了减少我们查找过程中的耗时。由于我们的merge过程就是把一个组的根节点直接指向另一个组的根节点，那么如果把一个很复杂的结构+到一个简单结构上，会增加整个树的深度，反之则不会增大复杂度。因此我们尽量让深度小的树 attach 到深度大的树上，效果如下图：<br>
<img src="https://hakuless.github.io//post-images/1558769263768.png" alt="两组进行合并" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769351883.png" alt="小树attach大树" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1558769433973.png" alt="大树attach小树" loading="lazy"><br>
可以明显看出，当大树attach小树时，复杂度明显增加，通过一个rank数组记录每一次做深节点的操作（Rank值相同的合并），并用于判断以后的union操作</p>
<h2 id="leetcode">LeetCode</h2>
<h3 id="684-redundant-connection">684. Redundant Connection</h3>
<p>标准的并查集题目，给出一组无向图的边，找到第一个使无相同中产生环的边 =&gt;<br>
转化为 将给出的边，按顺序把所有的点进行分组，直到发现某条边在添加之前，边的两个点就已经在一组里了，那么此时若加入这条边，即会产生环。</p>
<pre><code>class Solution {
    fun findRedundantConnection(edges: Array&lt;IntArray&gt;): IntArray {
        val dsu = DSU(edges.size)
        for (i in 0 until edges.size) {
            val x = edges[i][0] - 1
            val y = edges[i][1] - 1
            if (dsu.find(x) == dsu.find(y)) {
                return intArrayOf(x + 1, y + 1)
            }
            dsu.union(x, y)

        }
        return intArrayOf()
    }
}
</code></pre>
<h3 id="547-friend-circles">547. Friend Circles</h3>
<p>这个数据更直接的并查集题目，以二维数组形式 给出一个班级同学之间的朋友关系，1是朋友 0不是，同时 朋友的朋友也是朋友（...），然后给出整个班级一共有多少的朋友圈。。。</p>
<pre><code>class Solution {
    fun findCircleNum(M: Array&lt;IntArray&gt;): Int {
        val size = M.size
        val dsu = DSU(size)
        for (i in 0 until size) {
            for (j in 0 until size) {
                if (M[i][j] == 1 &amp;&amp; i != j) {
                    dsu.union(i, j)
                }
            }
        }

        val ans = HashSet&lt;Int&gt;()
        for (i in 0 until size) {
            ans.add(dsu.find(i))
        }
        return ans.size
    }
}
</code></pre>
<p>这里将所有的关系，录入到并查集中，然后遍历所有的学生所属的组放到Set里，那么Set的长度就是朋友圈的数量</p>
<h3 id="947-most-stones-removed-with-same-row-or-column">947. Most Stones Removed with Same Row or Column</h3>
<p>一般并查集的微变形，一个二维棋盘上，散落着一堆石头（每个石头一个点 且 不会有重复），然后我们可以一次一个的取下石头（对石头有要求，需要有其他石头和取下的石头在同一行 or 同一列，即自己单独一行 &amp; 一列 的石头无法取下，天煞孤石）<br>
这里，一组的属性是 行数 or 列数相同，Solution里给出的方案是根据 <strong>Note</strong> 中入参的限制来把 <em>列</em> 转换为 10000+的 <em>行</em> 数，我们这里采用更通用的办法，通过一个Map转换我们的Class ID与数据（ID与属性不需要有强关系）</p>
<pre><code>class Solution {
    fun removeStones(stones: Array&lt;IntArray&gt;): Int {
        val max = stones.size
        val ufs = TypedUFS&lt;IntArray&gt;(max)
        for (i in 0 until max) {
            for (j in i + 1 until max) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    ufs.union(stones[i], stones[j])
                }
            }
        }

        val set = hashSetOf&lt;Int&gt;()
        stones.forEach {
            val root = ufs.typedFind(it)
            set.add(root)
        }

        return stones.size - set.size
    }
}

class TypedUFS&lt;T&gt;(var n: Int = 0) {
    val parent = IntArray(n) { i -&gt; i }
    val rank = IntArray(n)

    val map = hashMapOf&lt;T, Int&gt;()
    var total = 0

    fun typedFind(key: T): Int {
        var x = total
        if (map.containsKey(key)) {
            x = map[key]!!
        } else {
            map[key] = total
            total++
        }
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun find(x: Int): Int {
        if (x != parent[x]) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun union(x: T, y: T): Boolean {
        val px = typedFind(x)
        val py = typedFind(y)
        if (px == py) {
            return false
        }
        when {
            rank[px] &gt; rank[py] -&gt; parent[py] = px
            rank[px] &lt; rank[py] -&gt; parent[px] = py
            else -&gt; {
                parent[px] = py
                rank[px]++
            }
        }
        return true
    }
}
</code></pre>
<p>把行、列有相同情况的元素union在一起，每个组都会留下一个元素，因此我们能有拿走的石头的最大数量就是 石头的数量 减去 并查集组的数量（与之前朋友圈的题目相似）。这里我们使用了一个 <strong>TypedUFS</strong> 来处理非int类型的源数据，map每次分配一个新元素一个新的Key值，最大程度的减少 <strong>parent</strong> 与 <strong>rank</strong> 数组的长度（最大只需要数据源的长度，而非数据源的范围，与Solution的区别）</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://zxi.mytechroad.com/blog/data-structure/sp1-union-find-set/">花花LeetCode</a><br>
<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">wiki</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search]]></title>
        <id>https://hakuless.github.io/post/binary-search</id>
        <link href="https://hakuless.github.io/post/binary-search">
        </link>
        <updated>2019-05-23T08:05:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<h4 id="what-is-binary-search">What is Binary Search</h4>
<p>Binary Search is one of the most fundamental and useful algorithms in Computer Science. It describes the process of search ing for a specific value in an ordered collection.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<h4 id="what-is-binary-search">What is Binary Search</h4>
<p>Binary Search is one of the most fundamental and useful algorithms in Computer Science. It describes the process of search ing for a specific value in an ordered collection.</p>
<!-- more --> 
<blockquote>
<p>Terminology used in Binary Search</p>
<ul>
<li>Target - the value tha you are searching for</li>
<li>Index - the current location that you are searching</li>
<li>Left, Right - the indicies from which we use to maintain ouer search Space</li>
<li>Mid - the index that we use to apply a condition to determine if we should search left or right</li>
</ul>
</blockquote>
<h3 id="how-does-it-work">How does it work?</h3>
<p>In its simplest form, Binary Sarch operates ona contiguous sequence with a specified left and right index. This is called the Search Space. Binary Search maintains the left, right and middle indicies of the search space and compares the search target or applies the search condition to the middle value of the collection; if the condition is unsatisfied or values unequal, the half in which the target cannnot lie is eliminated and the search continues on the remaining half until it is successful. if the search ends with an empty half, the condition cannot be fulfilled and target is not found.</p>
<h3 id="binary-search-template-i">Binary Search Template I</h3>
<pre><code>int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left &lt;= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] &lt; target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left &gt; right
  return -1;
}
</code></pre>
<h3 id="binary-search-template-ii">Binary Search Template II</h3>
<pre><code>int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length;
  while(left &lt; right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] &lt; target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.length &amp;&amp; nums[left] == target) return left;
  return -1;
}
</code></pre>
<h3 id="binary-search-template-iii">Binary Search Template III</h3>
<pre><code>int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 &lt; right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] &lt; target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
</code></pre>
<h3 id="binary-search-template-analysis">Binary Search Template Analysis</h3>
<p>These 3 templates differ by their:</p>
<ul>
<li>left, mid, right index assignments</li>
<li>loop or recursive termination condition</li>
<li>necessity of post-processing</li>
</ul>
<h4 id="template-1-left-right">Template #1 <strong>(left &lt;= right)</strong></h4>
<ul>
<li>Most basic and elmentary form of Binary search</li>
<li>Search Condition can be determined without comparing to the element's neighbors (or use specific elements around it)</li>
<li>No post-precessing required becasuse at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found</li>
</ul>
<h4 id="template-2-left-right">Template #2 <strong>(left &lt; right)</strong></h4>
<ul>
<li>An advanced way to implement Binary Search.</li>
<li>Search Condition needs to access element's immediate right neighbor</li>
<li>Use element's right neighbor to determine if condition is met and decide whether to go left or right</li>
<li>Gurantees Search Space is at least 2 in size at each step</li>
<li>Post-processing required. Loop/Recursion ends when you hava 1 element left. Need to assess if the remaining element meets the condition.</li>
</ul>
<h4 id="template-3-left-1-right">Template #3 <strong>(left + 1 &lt; right)</strong></h4>
<ul>
<li>An alternative way to implement Binary Search</li>
<li>Search Condition needs to access element's immediate left and right neighbors</li>
<li>Use element's neighbors to determine if condition is met and decide whether to go left or right</li>
<li>Gurantees Search Space is at least 3 in size at each step</li>
<li>Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS初级学习]]></title>
        <id>https://hakuless.github.io/post/css-chu-ji-xue-xi</id>
        <link href="https://hakuless.github.io/post/css-chu-ji-xue-xi">
        </link>
        <updated>2019-05-16T02:24:37.000Z</updated>
        <summary type="html"><![CDATA[<p>学习一下CSS，前端要是连设计稿都无法实现，基本需求都满足不了~</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习一下CSS，前端要是连设计稿都无法实现，基本需求都满足不了~</p>
<!-- more -->
<h2 id="css语法">CSS语法</h2>
<h3 id="基本规则">基本规则</h3>
<p>CSS主要由两部分组成：选择器(selector) &amp; 声明(declarations)</p>
<pre><code>/* selector {property: value} */
h1 {color:red; font-size:14px;}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hakuless.github.io//post-images/1557976004501.png" alt="" loading="lazy"></figure>
<h3 id="样式表书写">样式表书写</h3>
<p>目前，主要采用内联样式表的书写方案</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  	&lt;h1 style=&quot;color:red; font-size:14px;&quot;&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="规则">@规则</h3>
<p>通过@开头，后接标识符<br>
目前用的比较多的是 @keyframes，通过定义关键帧实现动画效果</p>
<pre><code>/* @keyframes */
@keyframes slidein {
    from {
        margin-left: 100%;
        width: 300%;
    }

    to {
        margin-left: 0%;
        width: 100%;
    }
}
</code></pre>
<h2 id="css工作流程">CSS工作流程</h2>
<h3 id="页面渲染机制">页面渲染机制</h3>
<p>页面渲染主要以下5个步骤：</p>
<ol>
<li>处理HTML来创建DOM tree；</li>
<li>处理CSS来创建CSSOM tree；</li>
<li>根据DOM跟CSSOM来合并render tree；</li>
<li>根据render tree来布局；</li>
<li>绘制render tree。</li>
</ol>
<h3 id="css的工作流程">CSS的工作流程</h3>
<p><img src="https://hakuless.github.io//post-images/1557976033477.png" alt="" loading="lazy"><br>
<strong>重排</strong> 与 <strong>重绘</strong></p>
<h2 id="css逻辑属性">CSS逻辑属性</h2>
<h3 id="新旧逻辑属性对比">新旧逻辑属性对比</h3>
<p><img src="https://hakuless.github.io//post-images/1557976478759.png" alt="" loading="lazy"><br>
新旧逻辑对比图表如下：</p>
<table>
<thead>
<tr>
<th>旧的逻辑属性</th>
<th>新的逻辑属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>margin-top</td>
<td>margin-block-start</td>
</tr>
<tr>
<td>margin-right</td>
<td>margin-inline-end</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>margin-block-end</td>
</tr>
<tr>
<td>margin-left</td>
<td>margin-inline-start</td>
</tr>
<tr>
<td>border-top</td>
<td>border-block-start</td>
</tr>
<tr>
<td>border-right</td>
<td>border-inline-end</td>
</tr>
<tr>
<td>border-bottom</td>
<td>border-block-end</td>
</tr>
<tr>
<td>border-left</td>
<td>border-inline-start</td>
</tr>
<tr>
<td>padding-top</td>
<td>padding-block-start</td>
</tr>
<tr>
<td>padding-right</td>
<td>padding-inline-end</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>padding-block-end</td>
</tr>
<tr>
<td>padding-left</td>
<td>padding-inline-start</td>
</tr>
<tr>
<td>width</td>
<td>inline-size</td>
</tr>
<tr>
<td>height</td>
<td>block-size</td>
</tr>
</tbody>
</table>
<p>Y轴方向属性使用 <strong>block</strong>，X轴方向属性使用 <strong>inline</strong></p>
<h3 id="css定位">CSS定位</h3>
<table>
<thead>
<tr>
<th>旧的逻辑属性</th>
<th>新的逻辑属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>inset-block-start</td>
</tr>
<tr>
<td>bottom</td>
<td>inset-block-end</td>
</tr>
<tr>
<td>left</td>
<td>inset-inline-start</td>
</tr>
<tr>
<td>right</td>
<td>inset-inline-end</td>
</tr>
</tbody>
</table>
<pre><code>/* 旧的逻辑属性 */
.popup{
  position:fixed;  
  top:0;
  bottom:0;
  left:0;
  right:0;
}
/* 新的逻辑属性 */
.popup{
   position:fixed;
   inset-block-start:0;  /*top - in English*/
   inset-block-end:0;    /*bottom - in English*/
   inset-inline-start:0; /*left - in English*/
   inset-inline-end:0;   /*right - in English*/
}
/* 新的逻辑属性支持简写 */
.popup{
   position:fixed;
   inset:0 0 0 0;   /*top, right, bottom, left - in English*/
}
</code></pre>
<p><img src="https://hakuless.github.io//post-images/1557977057594.png" alt="" loading="lazy"><br>
<img src="https://hakuless.github.io//post-images/1557977069217.png" alt="" loading="lazy"></p>
<h2 id="css盒子模型">CSS盒子模型</h2>
<p>待补充</p>
<h2 id="css选择器">CSS选择器</h2>
<h3 id="基本选择器">基本选择器</h3>
<ol>
<li>类型选择器： 直接html标签，如 html {width: 100%;}</li>
<li>类选择器：html标签中class属性的值，如 .div {width: 100%;}</li>
<li>ID选择器：现在不咋用了，通过html标签的ID属性来选择</li>
<li>通用选择器：更不会用... 所有标签生效...</li>
<li>属性选择器：根据html标签里的属性选择？？？</li>
</ol>
<h3 id="组合选择器">组合选择器</h3>
<ol>
<li>空格：后代选择器，<strong>.a .b</strong> 所有后代都生效</li>
<li>
<blockquote>
<p>：子代选择器，<strong>.a &gt; .b</strong> 只在一级儿子生效</p>
</blockquote>
</li>
<li>~：后继选择器，<strong>.a ~ .b</strong> 弟弟选择器，哥哥不生效</li>
<li>+：直接后继选择器，<strong>.a + .b</strong> 能生效的第一个弟弟生效</li>
<li>|：命名空间选择器，<strong>.a | .b</strong> 与后代类似</li>
<li>||：列表选择器，直接无视，这辈子都不会用的</li>
</ol>
<h3 id="伪类-与-伪元素">伪类 与 伪元素</h3>
<p><strong>伪类</strong>：伪类是添加到选择器的关键字，指定要选择的元素的特殊状态，如 a:hover，鼠标悬停状态的效果</p>
<pre><code>// 语法
selector:pseudo-class {
  property: value;
}
</code></pre>
<p><strong>伪元素</strong>：伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。一个选择器中只能使用一个伪元素，如 a::after { content: &quot;→&quot;; } 在所有a类型后增加一个箭头元素</p>
<pre><code>// 语法
selector::pseudo-element {
  property: value;
}
</code></pre>
<h3 id="css函数">CSS函数</h3>
<ul>
<li>属性函数：attr()；</li>
<li>背景图片函数：linear-gradient()、radial-gradient()、conic-gradient()、repeating-linear-gradient()、repeating-radial-gradient()、repeating-conic-gradient()、image-set()、image()、url()、element()；</li>
<li>颜色函数：rgb()、rgba()、hsl()、hsla()、hwb()、color-mod()；</li>
<li>图形函数：circle()、ellipse()、inset()、polygon()、path()</li>
<li>滤镜函数：blur()、brightness()、contrast()、drop-shadow()、grayscale()、hue-rotate()、invert()、opacity()、saturate()、sepia()；</li>
<li>转换函数：matrix()、matrix3d()、perspective()、rotate()、rotate3d()、rotateX()、rotateY()、rotateZ()、scale()、scale3d()、scaleX()、scaleY()、scaleZ()、skew()、skewX()、skewY()、translate()、translateX()、translateY()、translateZ()、translate3d()；</li>
<li>数学函数：calc()、min()、max()、mixmax()、repeat()；</li>
<li>缓动函数：cubic-bezier()、steps()；</li>
<li>其他函数：counter()、counters()、toggle()、var()、 symbols()。<br>
<a href="https://www.w3cplus.com/css/css-functions.html">CSS函数说明</a></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://krissarea.gitee.io/blog/">鱼头的海上世界</a><br>
<a href="https://www.w3.org/TR/?tag=css">CSS W3C标准文档</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS MDN文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS语法学习]]></title>
        <id>https://hakuless.github.io/post/js-yu-fa-xue-xi</id>
        <link href="https://hakuless.github.io/post/js-yu-fa-xue-xi">
        </link>
        <updated>2019-05-09T03:41:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="generators">Generators</h2>
<h2 id="promise">Promise</h2>
<h2 id="asyncawait">Async/Await</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stack & DFS]]></title>
        <id>https://hakuless.github.io/post/stack-and-dfs</id>
        <link href="https://hakuless.github.io/post/stack-and-dfs">
        </link>
        <updated>2019-02-19T12:00:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="stack-dfs">Stack &amp; DFS</h3>
<p>Similar to BFS, <strong>Depth-First Search</strong> can also be used to find the path from the root node to the target node.</p>
<p>The first path you found in DFS is not always the shortest path.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="stack-dfs">Stack &amp; DFS</h3>
<p>Similar to BFS, <strong>Depth-First Search</strong> can also be used to find the path from the root node to the target node.</p>
<p>The first path you found in DFS is not always the shortest path.</p>
<!-- more -->
<h3 id="dfs-template-i">DFS - Template I</h3>
<h4 id="template-recursion">Template - Recursion</h4>
<pre><code>/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
</code></pre>
<h3 id="dfs-template-ii">DFS - Template II</h3>
<p>The advantage of the recursion solution is that it is easier to implement. However, there is a huge disadvantage: if the depth of recursion is too high, youwill suffer from <strong>stack overflow</strong>.  In that case, you might want to use BFS instead or implement DFS using an explicit stack.</p>
<pre><code>/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set&lt;Node&gt; visited;
    Stack&lt;Node&gt; stack;
    add root to stack;
    while (s is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
</code></pre>
]]></content>
    </entry>
</feed>